/*
 * This file was generated automatically by ExtUtils::ParseXS version 2.2002 from the
 * contents of Vxglue.xs. Do not edit this file, edit Vxglue.xs instead.
 *
 *	ANY CHANGES MADE HERE WILL BE LOST! 
 *
 */

#line 1 "lib/Vxglue.xs"
//                    -*-C-*-

//  This file is part of Vxglue.
//  Copyright 2006,2007 Ampersand Inc., Doug Campbell
//
//  Vxglue is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 3 of the License, or
//  (at your option) any later version.
//
//  Vxglue is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with Vxglue; if not, see <http://www.gnu.org/licenses/>.

/*  This is C code, passed unchanged to the .c file  */
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"

#include <vglue_run.h>

/*  This starts the xsubpp-translated code  */

#line 38 "lib/Vxglue.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(pTHX_ const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
            Perl_croak(aTHX_ "Usage: %s::%s(%s)", hvname, gvname, params);
        else
            Perl_croak(aTHX_ "Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
        Perl_croak(aTHX_ "Usage: CODE(0x%"UVxf")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#ifdef PERL_IMPLICIT_CONTEXT
#define croak_xs_usage(a,b)	S_croak_xs_usage(aTHX_ a,b)
#else
#define croak_xs_usage		S_croak_xs_usage
#endif

#endif

#line 81 "lib/Vxglue.c"

XS(XS_Vxglue__PerlFree); /* prototype to pass -Wmissing-prototypes */
XS(XS_Vxglue__PerlFree)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	sv = ST(0);
#line 34 "lib/Vxglue.xs"
    void *ptr;
#line 99 "lib/Vxglue.c"
#line 36 "lib/Vxglue.xs"
    ptr = (void *) SvIV(SvRV(sv));
    if (ptr != NULL)
    {
	Safefree (ptr);
    };
#line 106 "lib/Vxglue.c"
	PUTBACK;
	return;
    }
}


XS(XS_Vxglue__start_voiceglue_platform); /* prototype to pass -Wmissing-prototypes */
XS(XS_Vxglue__start_voiceglue_platform)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 3)
       croak_xs_usage(cv,  "numChannels, logfd, loglevel");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	int	numChannels = (int)SvIV(ST(0));
	int	logfd = (int)SvIV(ST(1));
	int	loglevel = (int)SvIV(ST(2));
#line 47 "lib/Vxglue.xs"
/*  ($ok, $msg, $platform_handle) =              */
/*     _start_voiceglue_platform ($numChannels, $fd, $loglevel); */
    int ok = 1;
    SV *msg = &PL_sv_undef;
    void *platformHandle;
    int result;
#line 136 "lib/Vxglue.c"
#line 54 "lib/Vxglue.xs"
    result = voiceglue_start_platform
        (numChannels, logfd, loglevel, &platformHandle);
    if (result != 0)
    {
	ok = 0;
	msg = sv_2mortal (newSVpv("voiceglue_start_platform failed, check log",
				  0));
    };

    EXTEND (SP, 3);
    XPUSHs (sv_2mortal (newSViv (ok)));
    XPUSHs (msg);
    XPUSHs (sv_setref_pv (newSViv(0), NULL,
			  (void *) platformHandle));
#line 152 "lib/Vxglue.c"
	PUTBACK;
	return;
    }
}


XS(XS_Vxglue__start_voiceglue_thread); /* prototype to pass -Wmissing-prototypes */
XS(XS_Vxglue__start_voiceglue_thread)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 7)
       croak_xs_usage(cv,  "platform_handle, callid, ipcfd, url, ani, dnis, javascript_init");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	platform_handle = ST(0);
	int	callid = (int)SvIV(ST(1));
	int	ipcfd = (int)SvIV(ST(2));
	char *	url = (char *)SvPV_nolen(ST(3));
	char *	ani = (char *)SvPV_nolen(ST(4));
	char *	dnis = (char *)SvPV_nolen(ST(5));
	char *	javascript_init = (char *)SvPV_nolen(ST(6));
#line 75 "lib/Vxglue.xs"
/*  ($ok, $msg, $call_handle) =
     _start_voiceglue_thread ($platform_handle, $callid, $ipcfd, $url,
                              $ani, $dnis, $javascript_init);
 */
    int ok = 1;
    SV *msg = &PL_sv_undef;
    void *channel;
    int result;
    void *platform;
#line 189 "lib/Vxglue.c"
#line 85 "lib/Vxglue.xs"
    platform = (void *) SvIV(SvRV(platform_handle));

    result = voiceglue_start_thread
	(platform, callid, ipcfd, url, ani, dnis, javascript_init, &channel);
    if (result != 0)
    {
	ok = 0;
	msg = sv_2mortal (newSVpv("voiceglue_start_thread failed, check log",
				  0));
    };

    EXTEND (SP, 3);
    XPUSHs (sv_2mortal (newSViv (ok)));
    XPUSHs (msg);
    XPUSHs (sv_setref_pv (newSViv(0), NULL,
			  (void *) channel));
#line 207 "lib/Vxglue.c"
	PUTBACK;
	return;
    }
}


XS(XS_Vxglue__stop_voiceglue_thread); /* prototype to pass -Wmissing-prototypes */
XS(XS_Vxglue__stop_voiceglue_thread)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "call_handle");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	call_handle = ST(0);
#line 108 "lib/Vxglue.xs"
/*  ($ok, $msg) =
     _stop_voiceglue_stop_thread (call_handle); */
    int ok = 1;
    SV *msg = &PL_sv_undef;
    void *channelArgs;
    int result;
#line 235 "lib/Vxglue.c"
#line 115 "lib/Vxglue.xs"
    channelArgs = (void *) SvIV(SvRV(call_handle));

    result = voiceglue_stop_thread (channelArgs);
    if (result != 0)
    {
	ok = 0;
	msg = sv_2mortal (newSVpv("voiceglue_stop_thread failed, check log",
				  0));
    };

    EXTEND (SP, 2);
    XPUSHs (sv_2mortal (newSViv (ok)));
    XPUSHs (msg);
#line 250 "lib/Vxglue.c"
	PUTBACK;
	return;
    }
}


XS(XS_Vxglue__stop_voiceglue_platform); /* prototype to pass -Wmissing-prototypes */
XS(XS_Vxglue__stop_voiceglue_platform)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "platform_handle");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	platform_handle = ST(0);
#line 134 "lib/Vxglue.xs"
    int ok = 1;
    SV *msg = &PL_sv_undef;
    void *platform;
    int result;
#line 276 "lib/Vxglue.c"
#line 139 "lib/Vxglue.xs"
    platform = (void *) SvIV(SvRV(platform_handle));

    result = voiceglue_stop_platform (platform);
    if (result != 0)
    {
	ok = 0;
	msg = sv_2mortal (newSVpv("voiceglue_stop_platform failed, check log",
				  0));
    };

    EXTEND (SP, 2);
    XPUSHs (sv_2mortal (newSViv (ok)));
    XPUSHs (msg);
#line 291 "lib/Vxglue.c"
	PUTBACK;
	return;
    }
}


XS(XS_Vxglue__set_voiceglue_trace); /* prototype to pass -Wmissing-prototypes */
XS(XS_Vxglue__set_voiceglue_trace)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    if (items != 1)
       croak_xs_usage(cv,  "trace_level");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	int	trace_level = (int)SvIV(ST(0));
#line 159 "lib/Vxglue.xs"
#line 313 "lib/Vxglue.c"
#line 160 "lib/Vxglue.xs"
    voiceglue_set_trace (trace_level);
#line 316 "lib/Vxglue.c"
	PUTBACK;
	return;
    }
}

#ifdef __cplusplus
extern "C"
#endif
XS(boot_Vxglue); /* prototype to pass -Wmissing-prototypes */
XS(boot_Vxglue)
{
#ifdef dVAR
    dVAR; dXSARGS;
#else
    dXSARGS;
#endif
    const char* file = __FILE__;

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
    XS_VERSION_BOOTCHECK ;

        newXS("Vxglue::_PerlFree", XS_Vxglue__PerlFree, file);
        newXS("Vxglue::_start_voiceglue_platform", XS_Vxglue__start_voiceglue_platform, file);
        newXS("Vxglue::_start_voiceglue_thread", XS_Vxglue__start_voiceglue_thread, file);
        newXS("Vxglue::_stop_voiceglue_thread", XS_Vxglue__stop_voiceglue_thread, file);
        newXS("Vxglue::_stop_voiceglue_platform", XS_Vxglue__stop_voiceglue_platform, file);
        newXS("Vxglue::_set_voiceglue_trace", XS_Vxglue__set_voiceglue_trace, file);
    XSRETURN_YES;
}

