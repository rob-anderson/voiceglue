#!/usr/bin/perl --             -*-CPerl-*-

#############################################################
##  Copyright 2006-2010 Ampersand Inc., Doug Campbell
##
##  This is the voiceglue program.
##
##  Voiceglue is free software; you can redistribute it and/or modify
##  it under the terms of the GNU General Public License as published by
##  the Free Software Foundation; either version 3 of the License, or
##  (at your option) any later version.
##
##  Voiceglue is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
##  GNU General Public License for more details.
##
##  You should have received a copy of the GNU General Public License
##  along with Voiceglue; if not, see <http://www.gnu.org/licenses/>.

#############################################################
##  voiceglue: An OpenVXI (VXML) <-> SATC translator.
##    VMXL is a telephony control markup language and is implemented without
##    telephony support by the open source, GPL'd OpenVXI project.
##    SATC is Simple ASCII Telephony Control, a protocol
##    that provides call control and media control of multiple
##    telephone calls simultaneously, both inbound and outbound.
##    Astvxml implements OpenVXI telephony using SATC telephony client calls.
##    The voiceglue daemon, when started, first opens a connection
##    to a SATC server at port 44647 (thus becoming a SATC client).
##    It registers to receive SATC "incoming" messages
##    (corresponding to incomuing calls).
##    When incoming calls are signalled by SATC, voiceglue
##    runs the openVXI VXML engine on the call.
##    Telephony requests made by OpenVXI are translated
##    to SATC messages and forwarded to the SATC server.
##
#############################################################

use Config;
use Carp;
use Sys::Hostname qw(hostname);
use Socket;
use CGI;
use File::Path;
use POSIX ":sys_wait_h";
use Time::HiRes qw(gettimeofday);
use BSD::Resource;
use URI::Escape;
use XML::LibXML;
use Cam::Scom;
use Cam::Scom::Event;
use Satc;
use Voiceglue::Conf;
use SRGSDTMF;
use Vxglue;

use bytes;
use strict;

#################################################################
##  Tunables (times are all in seconds)
$::Retry_seconds_for_audio_fetch_failures = 60;
$::Default_soundcache_fetch_timeout = 7;
$::Default_soundcache_maxage = 60 * 5;
$::Cache_purge_interval = 60 * 7;
$::Cache_purge_unused_time = 60 * 4;
$::Blind_transfer_method = "transfer";
$::Cmd_host = "localhost";
$::Cmd_port = 44987;

#################################################################
##  Audio content type maps
$::File_extention_to_content_type =
{
 "ulaw" => "audio/basic",		## ulaw
 "au" => "audio/basic",			## ulaw
 "pcm" => "audio/basic",		## ulaw
 "ul" => "audio/basic",			## ulaw
 "mu" => "audio/basic",			## ulaw
 "alaw" => "audio/x-alaw-basic",	## alaw
 "al" => "audio/x-alaw-basic",		## alaw
 "wav" => "audio/x-wav",		## slin
 "mp3" => "audio/mpeg",			## mp3
 "gsm" => "audio/x-gsm",		## gsm
};

$::Content_type_to_file_extension =
{
 "audio/basic" => "ulaw",		## ulaw
 "audio/x-alaw-basic" => "alaw",	## alaw
 "audio/x-wav" => "wav",		## slin
 "audio/mpeg" => "mp3",			## mp3
 "audio/x-gsm" => "gsm",		## gsm
};


#################################################################
##  Logging setup
$::Logging_enabled = 0;      ##  Set to 1 when logging established
$::Log_dir = "/var/log/voiceglue";
$::Log_fh = "::LOG";
$::Loglevel = 7;
$::Max_log_file_size = 100000000;
$::Number_of_previous_kept = 2;
$::Time_of_next_connect_to_log_server = time;   ##  If non-0, failed to connect
$::Interval_between_log_server_connect_attempts = 120;
$::Dynlog_Mythread = sprintf ("%-8.8s", hostname() ."--------");
$::Dynlog_Mymodule = "VOICEGLU";
$::Dynlog_VXImodule = "OPEN_VXI";
@::Msg_level_strings =
  ("EMRG", "ALRT", "CRIT", "EROR", "WARN", "NOTI", "INFO", "DBUG");
use constant LOG_EMRG => 0;
use constant LOG_ALRT => 1;
use constant LOG_CRIT => 2;
use constant LOG_EROR => 3;
use constant LOG_WARN => 4;
use constant LOG_NOTI => 5;
use constant LOG_INFO => 6;
use constant LOG_DBUG => 7;

use constant VXIrec_RESULT_SUCCESS => 0;
use constant VXIrec_RESULT_FAILURE => 1;

#################################################################
##  Globals
$::Stop_requested = 0;	     ##  1 means process stop requested
$::Finished = 0;             ##  1 means done with main loop
$::VXML_threads = 0;         ##  How many current VXML threads
$::CmdFh = "::CMDLISTEN";    ##  Filehandle for the command listener
$::CmdInfo = undef;          ##  Shortcut to Clients->{$::CmdFh}
$::CTSrvFh = "::CTSRV";      ##  Filehandle for the CT Server
$::CTSrvInfo = undef;        ##  Shortcut to Clients->{$::CTSrvFh}
$::SSML_Passthrough = 0;     ##  Whether to pass full SSML tags to TTS

$::Clients = {};
##  Maps client fh's to:
##    ->{"type"}           -- one of the FHINFO_TYPE_* below
##    ->{"fh"}             -- filehandle
##    ->{"host"}           -- remote host
##   VXML_INTERP specific:
##    ->{"callid"}         -- if defined, the phoneglue callID handling
##    ->{"call_handle"}    -- the handle provided by the VXML interpreter
##    ->{"vxml_fd"}        -- IPC file descriptor used by VXML interpreter
##    ->{"connected"}      -- if defined, the call is connected (not hungup)
##    ->{"processing"}     -- 0 until first message from VXML interp received
##    ->{"satc_doing"}     -- if defined, contains the command the
##                            SATC server is running for this call
##    ->{"vxml_doing"}     -- if defined, contains the command the
##                            VXML interpreter is running for this call
##    ->{"gram_ids"}{<gram_id>}{"active"}  -- 1 = active 0 o.w.
##                             {"rule"}    -- the compiled rule
##    ->{"gram_texts"}{<gram_text>}{<gram_id>} -- 1 = gram text has gram_id
##    ->{"gram_signals"}   -- if defined, the list of currently active grammar
##                            signal characters to request
##    ->{"play_queued"}    -- if defined, contains the next prompts to play
##                            in the form of a promptspec:
##        [<index>]{"status"}       -- -1 = failed creation
##                                      0 = awaiting soundcache creation
##                                      1 = ready to play
##                                      2 = played
##                 {"type"}         -- "audio" or "dtmf"
##                 {"request_id"}   -- sound cache request id for this item
##                 {"bargein"}      -- 0 = no bargein, 1 = bargein
##                 {"path"}         -- file path to give SATC server or DTMFs
##    ->{"play_requested"} -- if defined, VXML requested a play of prompts
##                            that has not yet completed (due to a wait,
##                            recognize, or record being sent)
##    ->{"wait_requested"} -- if defined, VXML requested a wait 'till play done
##    ->{"recognize_requested"}  -- if defined, VXML requested a recognition
##                                  that has not yet completed.
##    ->{"record_requested"}  -- if defined, VXML requested a record
##                               that has not yet completed.
##    ->{"got_dtmf"}       -- if defined, DTMF keys that have been received
##                            (may be "" if termchar first char received)
##    ->{"rec_timeout"}    -- recognition/record initial silence timeout in ms
##    ->{"interdigittimeout"}    -- between-digit timeout in ms
##    ->{"termtimeout"}    -- timeout after match before terminator digit in ms
##    ->{"termchar"}       -- DTMF terminating character, or "" for none
##    ->{"rec_maxtime"}    -- if defined, max time for a rec in ms
##    ->{"rec_dtmfterm"}   -- whether to terminate record on DTMF
##    ->{"record_tone"}    -- whether to play a tone for record
##    ->{"rec_finalsilence"}-- final silence timeout of record in ms
##    ->{"rec_type"}       -- type of audio to record, one of "audio/basic",
##			      "audio/x-alaw-basic", "audio/x-wav"
##    ->{"rec_file"}       -- if defined, file currently recording into
##    ->{"timed_out"}      -- if defined, DTMF collection timed out
##    ->{"got_termchar"}   -- if defined, got DTMF termination character

##  Maps callid to filehandle of corresponding VXML_INTERP
$::Callid_to_vxml_fh = {};

##  Maps sound cache request id's to:
##    ->{"vxml_fh"}      -- filehandle of requesting VXML thread (may go away)
##    ->{"index"}        -- index of requested sound file in play_queued array
$::SC_request_id_info = {};

##  Maps grammar text to its SRGSDTMF-parsed rule
$::Gram_text_to_rule = {};

use constant FHINFO_TYPE_UNKNOWN => 0;
use constant FHINFO_TYPE_DYNLOG => 1;
use constant FHINFO_TYPE_VXILOG => 2;
use constant FHINFO_TYPE_CT_SERVER => 3;
use constant FHINFO_TYPE_VXML_INTERP => 4;
use constant FHINFO_TYPE_SOUND_CACHE => 5;
use constant FHINFO_TYPE_SOUND_CACHE_CLIENT => 6;
use constant FHINFO_TYPE_CMD_LISTENER => 7;
use constant FHINFO_TYPE_CMD => 8;
use constant FHINFO_TYPE_DEAD => 9;

@::Fhinfo_type_description =
  (
   "unknown",
   "DynLog",
   "VXML log",
   "CT server",
   "VXML interpreter",
   "Sound Cache",
   "Voiceglue Main",
   "Command Listener",
   "Command",
   "Dead"
  );

##  OVXI Messages
use constant OVXI_UNDEFINED => 0;
use constant OVXI_STARTED => 1;
use constant OVXI_ACTIVATEGRAMMAR => 2;
use constant OVXI_DEACTIVATEGRAMMAR => 3;
use constant OVXI_RECOGNIZE => 4;
use constant OVXI_PLAY => 5;
use constant OVXI_QUEUE => 6;
use constant OVXI_WAIT => 7;
use constant OVXI_BUILTIN => 8;
use constant OVXI_GETLINESTATUS => 9;
use constant OVXI_DISCONNECT => 10;
use constant OVXI_TRANSFER => 11;
use constant OVXI_RECORD => 12;
use constant OVXI_GRAMMAR => 13;
use constant OVXI_GETPCMPATH => 14;
use constant OVXI_PCMQUEUE => 15;
use constant OVXI_EXITVAL => 16;

$::OVXIMsgToOVXIType = {
			"started" => OVXI_STARTED,
			"ActivateGrammar" => OVXI_ACTIVATEGRAMMAR,
			"DeactivateGrammar" => OVXI_DEACTIVATEGRAMMAR,
			"Recognize" => OVXI_RECOGNIZE,
			"Play" => OVXI_PLAY,
			"Queue" => OVXI_QUEUE,
			"Wait" => OVXI_WAIT,
			"Builtin" => OVXI_BUILTIN,
			"GetLineStatus" => OVXI_GETLINESTATUS,
			"Disconnect" => OVXI_DISCONNECT,
			"Transfer" => OVXI_TRANSFER,
			"Record" => OVXI_RECORD,
			"Grammar" => OVXI_GRAMMAR,
			"GetPCMPath" => OVXI_GETPCMPATH,
			"PCMQueue" => OVXI_PCMQUEUE,
			"exitval" => OVXI_EXITVAL,
			};

$::OVXITypeToOVXIMsg = {};  ##  Filled in later from $::OVXIMsgToOVXIType

##  OVXI Input Message Decoding Table
##    Each element is [<fieldname>, ...]
$::OVXI_Input_Format =
{
 OVXI_STARTED() => ["msg"],
 OVXI_ACTIVATEGRAMMAR() => ["gram_id"],
 OVXI_DEACTIVATEGRAMMAR() => ["gram_id"],
 OVXI_RECOGNIZE() => ["properties"],
 OVXI_PLAY() => [],
 OVXI_QUEUE() => ["speak_spec", "bargein", "cookies"],
 OVXI_WAIT() => [],
 OVXI_BUILTIN() => ["grammar"],
 OVXI_GETLINESTATUS() => [],
 OVXI_DISCONNECT() => [],
 OVXI_TRANSFER() => ["url"],
 OVXI_RECORD() => ["properties"],
 OVXI_GRAMMAR() => ["gram_id", "gram_type", "grammar", "properties"],
 OVXI_GETPCMPATH() => ["pcm_id", "pcm_type"],
 OVXI_PCMQUEUE() => ["path", "bargein"],
 OVXI_EXITVAL() => ["varspec"],
};

##  OVXI Field Input Conversions

##  $hash = parse_ovxi_properties ($string)
##    Given $string containing OVXI properties in a=b;c=d form,
##    returns a hashref representing it
sub parse_ovxi_properties
{
    my ($string) = shift (@_);
    my ($result) = {};
    my ($ok, $msg, $spec, $specs);
    ($ok, $msg, $specs) = Satc::_parse_SATC_fields ($string);
    if (! $ok)
    {
	if ($::Loglevel >= LOG_EROR)
	{
	    logit (LOG_EROR,
		   "cannot parse properties: $msg on $string");
	};
	return $result;
    };
    foreach $spec (@$specs)
    {
	if ($spec =~ /^([^=]+)=(.+)$/)
	{
	    $result->{$1} = $2;
	};
    };
    return $result;
};

##  OVXI Field Input Conversion Table
##    Maps those OVXI field names that need conversion on input
$::OVXI_Input_Conversion =
{
 "properties" => \&parse_ovxi_properties,
};

use constant NLSML_NOINPUT => "<?xml version='1.0'?> <result> <interpretation> <instance/> <input><noinput/></input> </interpretation> </result>";
use constant NLSML_NOMATCH => "<?xml version='1.0'?> <result> <interpretation> <instance/> <input><nomatch/></input> </interpretation> </result>";

###########################################################
##  Message Data Structures

##  incoming OVXI messages are represented by a hash:
##    int msgtype;        //  one of the OVXI_* odes
##    int callid;
##    String msg;

#################################################################
##  Start of runtime code (sort of)

$::Next_screquest_id = 1000;

##  $string = dump_bytes ($item)
##    -- Returns one-line string representation of bytes in string $item
sub dump_bytes
{
    my ($item) = shift (@_);
    my ($result);

    $result = Satc::_escape_SATC_string ($item);
    return ($result);
};

$::Last_day = (localtime)[7];

##  Returns the system time in seconds in floating point
##  with up to microsecond resolution
sub systime
{
    my ($sec, $usec);

    ($sec, $usec) = gettimeofday();
    return ($sec + $usec / 1000000);
};

##  &four_byte_to_dot_separated ($four_byte_ip_addr)
##    Converts 4-byte IP addresses to dot-notation IP addresses
sub four_byte_to_dot_separated
{
    my ($four_byte) = shift (@_);
    return (join (".", unpack ("C4", $four_byte)));
};

##  ($ok, $msg, @lines) = getfile_lines ($path);
##    Reads an entire file, returns result in lines.
sub getfile_lines
{
    my ($path) = shift (@_);
    my (@lines);
    open (::VGGETFILEFH, $path)
      || return (0, "Cannot open \"$path\" for reading: $!");
    @lines = <::VGGETFILEFH>;
    close (::VGGETFILEFH)
      || return (0, "Cannot close \"$path\" after reading: $!");
    return (1, "", @lines);
};

##  ($ok, $msg, $contents) = getfile ($path);
##    Reads an entire file, returning result in single scalar.
sub getfile
{
    my ($path) = shift (@_);
    my ($ok, $msg, @lines);
    ($ok, $msg, @lines) = getfile_lines ($path);
    $ok || return ($ok, $msg, undef);
    return ($ok, $msg, join ("", @lines));
};

##  $result = urldecode_single ($urlencoded);
##    url-decodes a single parameter
sub urldecode_single
{
    my ($theURL) = shift (@_);
    $theURL =~ tr/+/ /;
    $theURL =~ s/%([a-fA-F0-9]{2,2})/chr(hex($1))/eg;
    $theURL =~ s/<!–(.|\n)*–>//g;
    return $theURL;
}

##  @params = urldecode ($input)
##    url-decodes zero or more parameters
sub urldecode
{
    my ($input) = shift (@_);
    return map {urldecode_single($_)} split (/&/, $input);
};

##  $result = clean_url_path ($url)
##    -- Removes "." and ".." from $url
sub clean_url_path
{
    my ($orig) = shift (@_);
    my (@components) = split (/\//, $orig);
    my ($new);
    my ($i) = 0;
    while ($i < scalar(@components))
    {
	if ($components[$i] eq ".")
	{
	    splice (@components, $i, 1);
	}
	elsif (($components[$i] eq "..") && ($i > 0))
	{
	    splice (@components, $i-1, 2);
	}
	else
	{
	    ++$i;
	};
    };
    $new = join ("/", @components);
    if ($orig ne $new)
    {
	if ($::Loglevel >= LOG_DBUG)
	{
	    logit (LOG_DBUG,
		   "clean_url_path() converted: \"$orig\" -> \"$new\"");
	};
    };
    return $new;
};

##  $result = parse_vxml_timeval ($string_value [, $default_units])
##    -- Returns millisecond representation of VXML time value
##       in $string_value, or undef if unparseable.
##       If units are missing, uses $default_units.
sub parse_vxml_timeval
{
    my ($string_value) = shift (@_);
    my ($default_units) = shift (@_);
    my ($number, $units);
    defined ($string_value) || return undef;
    if ($string_value =~ /^\s*\+?(\d+)(m?s)\s*$/)
    {
	$number = $1;
	$units = $2;
    }
    elsif ($string_value =~ /^\s*\+?(\.\d+)(m?s)\s*$/)
    {
	$number = $1;
	$units = $2;
    }
    elsif ($string_value =~ /^\s*\+?(\d+\.\d+)(m?s)\s*$/)
    {
	$number = $1;
	$units = $2;
    }
    elsif (defined ($default_units) &&
	    ($string_value =~ /^\s*\+?(\d+)\s*$/))
    {
	$number = $1;
	$units = $default_units;
    }
    elsif (defined ($default_units) &&
	   ($string_value =~ /^\s*\+?(\.\d+)\s*$/))
    {
	$number = $1;
	$units = $default_units;
    }
    elsif (defined ($default_units) &&
	   ($string_value =~ /^\s*\+?(\d+\.\d+)\s*$/))
    {
	$number = $1;
	$units = $default_units;
    }
    else
    {
	return undef;
    };
    if ($units eq "s")
    {
	return $number * 1000;
    };
    return $number + 0;
};

##  $result = parse_vxml_timeval ($string_value)
##    -- Returns boolean representation of VXML bool value
##       in $string_value, or undef if unparseable.
sub parse_vxml_bool
{
    my ($string_value) = shift (@_);
    defined ($string_value) || return undef;
    if ($string_value =~ /^\s*true\s*$/i)
    {
	return 1;
    };
    if ($string_value =~ /^\s*false\s*$/i)
    {
	return 0;
    };
    return undef;
};

##  $stopkeys = translate_stopkeys ($stopkeys)
##    --  Translates $stopkeys that may contain "+" for all
##        or "-" for none to the keysequence equivalent
sub translate_stopkeys
{
    my ($stopkeys) = shift (@_);

    ($stopkeys eq "+") && ($stopkeys = "0123456789#*");
    ($stopkeys eq "-") && ($stopkeys = "");
    return ($stopkeys);
};

##  openlogfile ($initial)
##    Opens a new log file, setting ::LOGFH to its handle.
##    The file name is taken from $::Logfile.
##    If $initial is true, append an existing file if reasonable.
##    Rotates existing log files that may already be there.
sub openlogfile
{
    my ($initial) = shift (@_);
    my ($i, $from, $to, @params);

    if ($::Logfile eq "-")
    {
	##  Just use STDOUT
	open (::LOGFH, ">&STDOUT")
	  || die ("cannot open ::LOGFH to STDOUT (dup): $!");
    }
    else
    {
	##  See if the current file is OK (if initial)
	if ($initial &&
	    scalar (@params = stat ($::Logfile)) &&
	    defined ($params[7]) &&
	    ($params[7] < ($::Max_log_file_size - 1024)))
	{
	    ##  Current one is OK
	    open (::LOGFH, ">>$::Logfile")
	      || warn ("Cannot open \"$::Logfile\" for writing: $!");
	    $::Current_log_file_size = $params[7];
	    select ((select (::LOGFH), $| = 1)[0]);
	}
	else
	{
	    ##  Rotate
	    for ($i = $::Number_of_previous_kept - 1; $i >= 0; --$i)
	    {
		$from = join (".", $::Logfile, $i);
		$to = join (".", $::Logfile, $i+1);
		(-e $from) && rename ($from, $to);
	    };
	    (-e $::Logfile)
	      && rename ($::Logfile, join (".", $::Logfile, "0"));
	    ##  Open new
	    open (::LOGFH, ">$::Logfile")
	      || warn ("Cannot open \"$::Logfile\" for writing: $!");
	    $::Current_log_file_size = 0;
	    select ((select (::LOGFH), $| = 1)[0]);
	};
    };
};

sub log_new_day
{
    my ($out);
    my (@dateinfo) = localtime;

    if ((! defined ($::Loghost)) || $::Time_of_next_connect_to_log_server)
    {
	$::Last_day = $dateinfo[7];
	$out = join (" ",
		     "============",
		     "====",
		     "LOGSRV",
		     "LGSRVMAI",
		     "Today is",
		     sprintf ("%04d/%02d/%02d",
			      $dateinfo[5] + 1900,
			      $dateinfo[4] + 1,
			      $dateinfo[3]
			     )) . "\n";
	(print ::LOGFH ($out))
	  || warn ("Cannot write to log file: $!");
	$::Current_log_file_size += length ($out);
    };
};

##  logtofile ($msg_level, $msg, $module_name, $thread_name)
##    Logs to the log file the with level $msg_level
##    message $msg with module name $module_name
sub logtofile
{
    my ($msg_level) = shift (@_);
    my ($msg) = shift (@_);
    my ($module_name) = shift (@_);
    my ($thread_name) = shift (@_);
    my ($out, $usec, $timestamp, @dateinfo);

    ($msg_level <= $::Loglevel) || return;
    ($msg =~ /\n$/) || ($msg .= "\n");

    ##  Check for need to rotate
    if (($::Logfile ne "-") &&
	($::Current_log_file_size >= $::Max_log_file_size))
    {
	(print ::LOGFH
	 ("============ ==== LOGSRV LGSRVMAI End log file, rotating log\n"))
	  || warn ("Cannot write to log file: $!");
	&openlogfile (0);
    };

    $usec = systime();
    @dateinfo = localtime (int ($usec));
    if ($::Last_day != $dateinfo[7])
    {
	##  The day just changed
	log_new_day();
    };
    $timestamp = join ("", sprintf ("%02d:%02d:%02d:%03d",
				    $dateinfo[2],
				    $dateinfo[1],
				    $dateinfo[0],
				    int ($usec / 1000)));
    $out = join (" ",
		 $timestamp,
		 (($msg_level < 0) ? "====" :
		  $::Msg_level_strings[$msg_level]),
		 $module_name,
		 $msg);
    (print ::LOGFH ($out))
      || Carp::cluck ("Cannot write to log file: $!");
    $::Current_log_file_size += length ($out);
};

##  opendynlog()
##    Attempts to open a connection to the dynlog server.
##    On success, it sets $::Time_of_next_connect_to_log_server to 0.
sub opendynlog
{
    my ($ok, $msg);

    $::Time_of_next_connect_to_log_server &&
      logtofile (LOG_INFO, "connecting to log server on host $::Loghost",
		 $::Dynlog_Mymodule, $::Dynlog_Mythread);
    ($ok, $msg) = $::Scom->connect ($::Log_fh, $::Loghost, 6410, ".:", 1);
    if (! $ok)
    {
	logtofile (LOG_INFO,
		   "cannot connect to log server on host $::Loghost: $msg",
		   $::Dynlog_Mymodule, $::Dynlog_Mythread);
	$::Time_of_next_connect_to_log_server =
	  time + $::Interval_between_log_server_connect_attempts;
    }
    else
    {
	$::Time_of_next_connect_to_log_server = 0;
	$::Fhinfo->{$::Log_fh} = {"type" => FHINFO_TYPE_DYNLOG,
				  "host" => (gethostbyname ($::Loghost))[4]};
    };
};

##  &dynlog ($log_level, $msg, $module_name, $thread_name);
##    Submit a logging message $msg at level $log_level
sub dynlog
{
    my ($msg_level) = shift (@_);
    my ($logmsg) = shift (@_);
    my ($module_name) = shift (@_);
    my ($thread_name) = shift (@_);
    my ($ok, $msg, $tdstamp, $sec, $usec, @dateinfo, $timestamp, $dynlogmsg);

    $::Time_of_next_connect_to_log_server && return;
    ($msg_level > $::Loglevel)  && return;
    if ($msg_level == -1)
    {
	##  A status/event message
    }
    else
    {
	##  A log message
	$dynlogmsg = $logmsg;
	$dynlogmsg =~ s/\n/\x01/gs;
	$dynlogmsg = $msg_level . $module_name ." "
	  . $thread_name . "\t" . $dynlogmsg . "\n"
    };
    if (! (($ok, $msg) = $::Scom->write ($::Log_fh, $dynlogmsg))[0])
    {
	logtofile (LOG_INFO,
		   "error writing to log server on host $::Loghost: $msg\n",
		   $::Dynlog_Mymodule, $::Dynlog_Mythread);
	logtofile ($msg_level, $logmsg,
		   $::Dynlog_Mymodule, $::Dynlog_Mythread);
	$::Scom->unregister ($::Log_fh);
	$::Time_of_next_connect_to_log_server =
	  time + $::Interval_between_log_server_connect_attempts;
    };
};

##  logit ($msg_level, $msg [, $module [, $thread]])
##    Logs to the current log destination with level $msg_level
##    message $msg.  Optionally supply $module name and $thread name.
sub logit
{
    my ($msg_level) = shift (@_);
    my ($msg) = shift (@_);
    my ($module_name) = shift (@_);
    my ($thread_name) = shift (@_);

    ($msg_level <= $::Loglevel) || return;

    $msg =~ s/\n/\\n/g;

    defined ($module_name) || ($module_name = $::Dynlog_Mymodule);
    defined ($thread_name) || ($thread_name = $::Dynlog_Mythread);

    if ((! defined ($::Loghost)) || $::Time_of_next_connect_to_log_server)
    {
	logtofile ($msg_level, $msg, $module_name, $thread_name);
    }
    else
    {
	dynlog ($msg_level, $msg, $module_name, $thread_name);
    };
};

##  &fail ($msg)
##    -- This die handler outputs to logit before exit
sub fail
{
    my ($msg) = shift (@_);
    my ($fh);

    if (defined ($::Loghost) && (! $::Time_of_next_connect_to_log_server))
    {
	##  Dynlog is running.  First, kill all non-logging handles.
	foreach $fh (keys (%$::Fhinfo))
	{
	    if ($fh ne $::Log_fh)
	    {
		$::Scom->unregister ($fh);
	    };
	};
	##  Next, send the message and wait for it to finish, 10 seconds max
	dynlog (LOG_CRIT, Carp::longmess ($msg),
		$::Dynlog_Mymodule, $::Dynlog_Mythread);
	$::Scom->close_on_flush ($::Log_fh);
	while (scalar ($::Scom->getevents (10))) {};
    }
    else
    {
	logtofile (LOG_CRIT, Carp::longmess ($msg),
		   $::Dynlog_Mymodule, $::Dynlog_Mythread);
    };

    confess ($msg);
};

##  ($ok, $msg, $maxfds) = &increase_descriptors()
##    Increases file descriptors to the max, and returns how many in $maxfds
##    and how many it started out as in $origfds
sub increase_descriptors
{
    my ($rlimit_max, $rlimit_cur, $rlimit_new);
    my ($resource) = RLIMIT_NOFILE;

    scalar (($rlimit_cur, $rlimit_max) = getrlimit ($resource))
      || return (0, "getrlimit failed $!");
    ##  File descriptor limit started at $rlimit_cur
    $rlimit_new = $rlimit_max;
    $> || ($rlimit_new = 8192);
    setrlimit ($resource, $rlimit_new, $rlimit_new)
      || return (0, "setrlimit failed: $!");
    ## File descriptor limit set to maximum $rlimit_cur
    return (1, "", $rlimit_new);
};

##  ($ok, $msg) = &enable_core_dumps()
##    Enables core dumps
sub enable_core_dumps
{
    my ($rlimit_max, $rlimit_cur);
    my ($resource) = RLIMIT_CORE;

    scalar (($rlimit_cur, $rlimit_max) = getrlimit ($resource))
      || return (0, "getrlimit failed $!");
    $rlimit_cur = $rlimit_max;
    setrlimit ($resource, $rlimit_cur, $rlimit_max)
      || return (0, "setrlimit failed: $!");
    return (1, "");
};

##  &describe_fh ($fh)
##    Returns text description of client at fh $fh (for logging)
sub describe_fh
{
    my ($fh) = shift (@_);
    my ($fhinfo, $result);

    (defined ($fhinfo = $::Clients->{$fh}))
      || return ("unknown fh=\"$fh\"");
    $result = $::Fhinfo_type_description[$fhinfo->{"type"}] .
      " on fh=\"$fh\" at host=" . $fhinfo->{"host"};
    defined ($fhinfo->{"callid"})
      && ($result .= " callid=[" . $fhinfo->{"callid"} . "]");
    return ($result);
};

##  remove_client ($client_fh)
##    Removes client from internal data structures
##    (Does not affect system filehandles)
sub remove_client
{
    my ($fh) = shift (@_);

    delete $::Clients->{$fh};
};

##  fh_stopped ($fh, $msg)
##    -- Entry point for when any filehandle terminates.
##       If $msg is length non-0, then it contains the
##       failure reason for the stoppage.
sub fh_stopped
{
    my ($fh) = shift (@_);
    my ($msg) = shift (@_);
    my ($ok, $fhinfo, $type, $severity, $logmsg, $callid);

    ##  Determine severity
    defined ($fhinfo = $::Clients->{$fh})
      && ($type = $fhinfo->{"type"});
    if ((! defined ($type)) ||
	($type == FHINFO_TYPE_UNKNOWN) ||
	($type == FHINFO_TYPE_DEAD) ||
	($type == FHINFO_TYPE_CMD_LISTENER) ||
	($type == FHINFO_TYPE_CMD) ||
	($type == FHINFO_TYPE_VXML_INTERP))
    {
	$severity = LOG_EROR;
    }
    elsif (($type == FHINFO_TYPE_CT_SERVER) ||
	   ($type == FHINFO_TYPE_SOUND_CACHE))
    {
	$severity = LOG_EMRG;
    }
    else
    {
	$severity = LOG_INFO;
    };

    $logmsg = $::Fhinfo_type_description[$type] .
      " filehandle \"$fh\" stopped: " . $msg;
    if ($::Loglevel >= $severity)
    {
	logit ($severity, $logmsg);
    };
    ($severity == LOG_EMRG) && fail ($logmsg);

    if ($type == FHINFO_TYPE_SOUND_CACHE_CLIENT)
    {
	if ($::Loglevel >= LOG_NOTI)
	{
	    logit (LOG_NOTI, "Sound Cache terminating");
	};
	##  Suck up all children so there are no zombies
	waitfor_soundcache_children();
	exit (0);
    };

    if ($type == FHINFO_TYPE_VXML_INTERP)
    {
	$callid = $fhinfo->{"callid"};
	if ((! $ok)  && ($::Loglevel >= LOG_EROR))
	{
	    logit (LOG_EROR, "callid=[" . $callid .
		   "] lost its VXML interpreter");
	};

	##  Must clean up the VXML thread
	if ((! $ok)  && ($::Loglevel >= LOG_DBUG))
	{
	    logit (LOG_DBUG, "callid=[" . $callid .
		   "] deallocating VXML thread");
	};
	($ok, $msg) = Vxglue::_stop_voiceglue_thread ($fhinfo->{"call_handle"});
	if ((! $ok)  && ($::Loglevel >= LOG_EROR))
	{
	    logit (LOG_EROR, "callid=[" . $callid .
		   "] got failure from _stop_voiceglue_thread");
	};
	--$::VXML_threads;

	if (defined ($callid) && defined ($fhinfo->{"connected"}))
	{
	    ##  Must release the call
	    ($::Loglevel >= LOG_NOTI)
	      && logit (LOG_NOTI, "callid=[" . $callid .
			"] releasing call because VXML interpreter exited");
	    send_ct_client_msg
	      ($::CTSrvInfo, {Satc::MSGTYPE => Satc::RELEASE,
			      Satc::CALLID => $callid});
	    delete $fhinfo->{"connected"};
	};
	POSIX::close ($fhinfo->{"vxml_fd"});
	delete $::Callid_to_vxml_fh->{$callid};
	if (($::VXML_threads == 0) && ($::Stop_requested))
	{
	    $::Finished = 1;
	};
    };

    remove_client ($fh);
};

##  ($ok, $msg, $result) = parse_ovxi_msg ($fh_spec, $bytes)
##    Returns in $result a hash representing the parsed OpenVXI message
##    in $bytes that came in on filehandle with hash representation $fh_spec.
sub parse_ovxi_msg
{
    my ($fh_spec) = shift (@_);
    my ($bytes) = shift (@_);
    my ($ok, $msg, $field_name, $conversion);
    my ($orig_bytes, $msgtype, $format, $field, $quotechar, $fields);

    ##  Have to decode OpenVXI msg in $bytes

    ##  First, break it into fields and get the msgtype
    $orig_bytes = $bytes;
    (($ok, $msg, $fields) = Satc::_parse_SATC_fields ($bytes))[0]
      || return (0, "Cannot parse SATC message \"" . $orig_bytes . "\": $msg");
    scalar (@$fields)
      || return (0, "Ignoring empty SATC message \"" . $orig_bytes . "\"");
    defined ($msgtype = $::OVXIMsgToOVXIType->{$fields->[0]})
      || return (0, "Unknown OVXI command \"" . $fields->[0] .
		 "\" in message \"" . $orig_bytes . "\"");

    ##  Now build up hash representing the message
    defined ($format = $::OVXI_Input_Format->{$msgtype})
      || return (0, "Unknown OVXI format for \"" . $fields->[0] .
		 "\" in message \"" . $orig_bytes . "\"");
    $msg = {msgtype => $msgtype};
    shift (@$fields);
    foreach $field_name (@$format)
    {
	defined ($field = shift (@$fields))
	  || return (0,  "Insufficient fields in OVXI message \"" .
		     $orig_bytes . "\"");
	if (defined ($conversion = $::OVXI_Input_Conversion->{$field_name}))
	{
	    $field = &$conversion ($field);
	};
	$msg->{$field_name} = $field;
    };

    ##  Callid is implicit in the fh_info
    $msg->{Satc::CALLID} = $fh_spec->{"callid"};

    return (1, "", $msg);
};

##  describe_ovxi_msg ($msg)
##    --  Returns string describing the OVXI message
##        contained in hash $msg
sub describe_ovxi_msg
{
    my ($msg) = shift (@_);
    my (@result) = ();
    my ($msgtype) = $msg->{"msgtype"};
    my ($field, $value);

    push (@result, $::OVXITypeToOVXIMsg->{$msgtype});
    push (@result, " callid=", $msg->{"callid"});
    foreach $field (sort (keys (%$msg)))
    {
	if (($field ne "callid") && ($field ne "msgtype") &&
	    (defined ($value = $msg->{$field})))
	{
	    push (@result, " " . $field . "=" . $value);
	};
    };
    return (join ("", @result));
};

##  send_bytes ($fhinfo, $bytes)
##    -- Sends $bytes to filehandle represented by $fhinfo
sub send_bytes
{
    my ($fhinfo) = shift (@_);
    my ($bytes) = shift (@_);
    my ($ok, $msg);

    if ($fhinfo->{"type"} == FHINFO_TYPE_DEAD)
    {
	($::Loglevel >= LOG_DBUG)
	  && logit (LOG_DBUG, "Not sending " .
		    dump_bytes ($bytes) .
		    " to "  . describe_fh ($fhinfo->{"fh"}));
	return;
    };

    ($::Loglevel >= LOG_DBUG)
      && logit (LOG_DBUG, "snd " .
		dump_bytes ($bytes) .
		" to "  . $fhinfo->{"fh"});

    ($ok, $msg) = $::Scom->write ($fhinfo->{"fh"}, $bytes);
    if (! $ok)
    {
	fh_stopped ($fhinfo->{"fh"}, $msg);
    };
};

##  send_ct_client_msg ($ctinfo, $ct_server_msg)
##    -- Sends $ct_client_msg to the CT Server at $ctinfo
sub send_ct_client_msg
{
    my ($ctinfo) = shift (@_);
    my ($ctmsg) = shift (@_);
    my ($ok, $msg, $format_string, $fmt, $type, $msgsize, $bytes, $callid);
    my ($format, $field, $field_name, $conversion, $vxml_fh, $vxmlinfo);
    my ($loglevel) = LOG_DBUG;
    my (@tosend) = ();

    ##  Convert it to serialized form
    if (! (($ok, $msg, $bytes) = $::Satc->encode ($ctmsg))[0])
    {
	($::Loglevel >= LOG_EROR)
	  && logit (LOG_EROR,
		    "Cannot encode Satc message " .
		    $::Satc->describe_msg ($ctmsg) .
		    ": $msg ; cannot send to "
		    . describe_fh ($ctinfo->{"fh"}));
	return;
    };

    ##  Send it off, logging media messages a little higher
    $callid = $ctmsg->{Satc::CALLID};
    $type = $ctmsg->{Satc::MSGTYPE};
    if (($type == Satc::PLAY) ||
	($type == Satc::PLAYDIG) ||
	($type == Satc::RECORD) ||
	($type == Satc::GETDIG) ||
	($type == Satc::HANGUP))
    {
	$loglevel = LOG_INFO;
    };
    ($::Loglevel >= $loglevel)
      && logit ($loglevel, (defined ($callid) ?
			    ("callid=[" . $callid . "] ") : "")
		. "snd " . $::Satc->describe_msg ($ctmsg) .
		" to "  . describe_fh ($ctinfo->{"fh"}));

    ##  Update satc_doing
    if (defined ($callid) &&
	defined ($vxml_fh = $::Callid_to_vxml_fh->{$callid}))
    {
	$vxmlinfo = $::Clients->{$vxml_fh};
	$vxmlinfo->{"satc_doing"} = $ctmsg->{Satc::MSGTYPE};
    };

    send_bytes ($ctinfo, $bytes);
};

##  ($ok, $msg, $node) = nodelist_to_node ($node, $identifier)
##    If parameter $node is not an XML::LibXML::NodeList, reutrns $node.
##    If parameter $node is an XML::LibXML::NodeList and has one element,
##    returns that element.
##    If none of the above, returns undef for $node, and sets
##    $msg to an error message using $identifier as the identifier of the node.
sub nodelist_to_node
{
    my ($node) = shift (@_);
    my ($identifier) = shift (@_);

    if ($node->isa ("XML::LibXML::NodeList"))
    {
	if (scalar ($node->get_nodelist) != 1)
	{
	    return (0, "XML data invalid: " .
		    $identifier . " has " .
		    scalar ($node->get_nodelist) .
		    " items (should be 1)\n");
	};
	return (1, "", ($node->get_nodelist)[0]);
    }
    else
    {
	return (1, "", $node);
    };
};

##  ($ok, $msg, $prefix, $hosturl) = url_base_to_prefix ($base)
##    -- Given a url in $base, converts it
##       to a  $prefix (with trailing "/"), and
##       a $hosturl (up tthrough the hostname) (no trailing "/").
##       If $base is empty, returns "" and "" for $prefix and $hosturl.
sub url_base_to_prefix
{
    my ($base) = shift (@_);
    my ($prefix, $hosturl, @nodes);

    if ((! defined ($base)) || (! length ($base)))
    {
	return (1, "", "", "");
    };
    if ($base =~ /\/[^\/]+$/s)
    {
	$prefix = $base;
	$prefix =~ s/[^\/]+$//s;
	if ($base =~ /^([^\/:]+:\/\/[^\/]+)\//s)
	{
	    $hosturl = $1;
	    return (1, "", $prefix, $hosturl);
	};
    };
    return (0, "Cannot parse base URL \"$base\"");
};

##  $clean_text = clean_tts_text ($tts_text)
##    -- Returns $tts_text with ends cleaned of whitespace
##       and newlines replaced with spaces
sub clean_tts_text
{
    my ($tts_text) = shift (@_);
    $tts_text =~ s/^\s+//s;
    $tts_text =~ s/\s+$//s;
    $tts_text =~ s/\n/ /sg;
    return $tts_text;
};

##  $text = extract_tts($xml_node);
##    Given speak spec XML node $xml_node, extracts the TTS text for it.
##    Will return "" if none found.
sub extract_tts
{
    my ($xml_node) = shift;
    my ($text);

    if ($::SSML_Passthrough)
    {
	$text = $xml_node->toString();
    }
    else
    {
	$text = $xml_node->textContent;
    }
    if (defined ($text) && length ($text))
    {
	$text = clean_tts_text ($text);
    }
    defined ($text) || ($text = "");
    return $text;
};

##  ($ok, $msg, [@specs]) = parse_speak_xml ($xml_text);
##    Given XML text in $xml_text, extracts into @specs a list of hashes
##    containing the following fields:
##                 {"tts"}          -- if defined, the tts text to convert
##                 {"url"}          -- if defined, the url to download
##                 {"timeout"}      -- in seconds for creation
##                 {"maxage"}       -- if defined, in seconds for cacheing
##                 {"lang"}         -- the xml:lang value (e.g. "en")
sub parse_speak_xml
{
    my ($xml_text) = shift (@_);
    my ($xml_parser, $xml_doc, $root, $node, $ok, $msg, $specs, $audio_url);
    my (@children, $child, $xmlbase, $prefix, $hosturl, $src, @nodes);
    my ($spec, $text, $maxage, $timeout, $lang);

    ##  For some reason, OpenVXI is passing \x90 and \x902x for spaces
    $xml_text =~ s/\x902x/ /g;
    $xml_text =~ s/\x90/ /g;

    ##  Parse the <speak>
    $xml_parser = XML::LibXML->new();
    eval
    {
	$xml_doc = $xml_parser->parse_string ($xml_text);
    };
    (length ($@))
      && (return (0, "Cannot parse prompt XML: $@"));

    ##  Look for xml:base in the root
    $root = $xml_doc->documentElement;
    ##  Parse out the url prefix for this <speak>
    $xmlbase = $root->findvalue ("\@xml:base");
    (($ok, $msg, $prefix, $hosturl) = url_base_to_prefix ($xmlbase))[0]
      || return (0, "xml:base parse error: $msg");

    ##  Look for xml:lang in the root
    $root = $xml_doc->documentElement;
    $lang = $root->findvalue ("\@xml:lang");
    defined ($lang) && length ($lang) || ($lang = "en");

    ##  Extract specs from all <audio> children
    $specs = [];
    @children = $root->childNodes;
    foreach $child (@children)
    {
	if ($child->nodeName eq "audio")
	{
	    $spec = {};

	    ##  Look for src
	    $src = $child->findvalue ("\@src");
	    if (defined ($src) && length ($src))
	    {
		if ($src =~ /^\//)
		{
		    ##  Absolute path
		    $audio_url = $hosturl . $src;
		}
		elsif ($src =~ /^[^:]+:\/\//s)
		{
		    ##  Absolute url
		    $audio_url = $src;
		}
		else
		{
		    ##  Relative url
		    $audio_url = $prefix . $src;
		};
		$spec->{"url"} = $audio_url;
	    };

	    ##  Look for maxage
	    $maxage = $child->findvalue ("\@maxage");
	    if (defined ($maxage) && length ($maxage))
	    {
		$spec->{"maxage"} = $maxage;
	    };

	    ##  Look for timeout
	    $timeout = $child->findvalue ("\@fetchtimeout");
	    if (defined ($timeout) && length ($timeout))
	    {
		$spec->{"timeout"} = $timeout;
	    };

	    ##  Look for tts text
	    $text = extract_tts($child);
	    if (length ($text))
	    {
		$spec->{"tts"} = $text;
	    };

	    if (defined ($spec->{"tts"}) ||
		defined ($spec->{"url"}))
	    {
		$spec->{"lang"} = $lang;
		push (@$specs, $spec);
	    };
	}
	elsif (($child->nodeName eq "text") ||
	       ($child->nodeName eq "#text"))
	{
	    ##  This is just raw tts, no enclosing <audio>
	    $spec = {};
	    $text = extract_tts($child);
	    if (length ($text))
	    {
		$spec->{"tts"} = $text;
		$spec->{"lang"} = $lang;
		push (@$specs, $spec);
	    };
	};
    };

    return (1, "", $specs);
};

##  Returns perl variable suitable for r.h.s. of assignment
##  in javascript code, enclosed by single-quotes.
sub quote_javascript_string
{
    my ($orig) = shift;
    $orig =~ s/'/\\'/g;
    return "'" . $orig . "'";
}

##  handle_satc_incoming ($ctmsg)
##    -- Handles SATC inoming message in $ctmsg
sub handle_satc_incoming
{
    my ($ctmsg) = shift (@_);
    my ($callid, $perl_fh, $c_fh, $fh_spec, $call_handle);
    my ($ok, $msg, $url, $ani, $dnis, $hangup_msg, $r, $arg, $part, @parts);
    my ($urlparam, $urlparam_value, $args, %arghash, $c_fd, $pos, @arp_params);
    my ($javascript_init) = "";

    ##  Refresh the DNIS->URL mapping if necessary
    if (! (($ok, $msg) = parse_configfile())[0])
    {
	($::Loglevel >= LOG_CRIT)
	  && logit (LOG_CRIT, "Failure parsing $::Conffile: $msg");
	return;
    };
    if ($ok == 2)
    {
	##  Just got a new set of DNIS mappings
	($::Loglevel >= LOG_NOTI)
	  && logit (LOG_NOTI, "Found changed urlfile, loaded " .
		    scalar (keys (%$::URLmap)) .
		    " mappings");
    };

    ##  Extract the phoneglue incoming call information
    $callid = $ctmsg->{Satc::CALLID};
    $dnis = $ctmsg->{Satc::DNIS};
    $ani = $ctmsg->{Satc::ANI};
    $arg = $ctmsg->{Satc::ARG};

    ##  If there is an arg, parse out URL and/or params from it
    if (defined ($arg) && length($arg))
    {
	$args = new CGI($arg);
	%arghash = $args->Vars;

	foreach $urlparam (keys (%arghash))
	{
	    $urlparam_value = $arghash{$urlparam};
	    if ($urlparam eq "url")
	    {
		##  Extract special name "url" if found
		$url = $urlparam_value;
		delete $arghash{$urlparam};
	    }
	    else
	    {
		##  Substitute for fields:
		##    %%ani=	-- substitute ani
		##    %%dnis=	-- substitute dnis
		##    %%callid=	-- substitute phoneglue callid
		($urlparam_value =~ /[^=]+=\%\%ani$/)
		  && ($urlparam_value =~ s/=\%\%ani$/=$ani/);
		($urlparam_value =~ /[^=]+=\%\%dnis$/)
		  && ($urlparam_value =~ s/=\%\%dnis$/=$dnis/);
		($urlparam_value =~ /[^=]+=\%\%callid$/)
		  && ($urlparam_value =~ s/=\%\%callid$/=$callid/);
		$arghash{$urlparam} = $urlparam_value;
	    };
	};

	if (scalar (keys (%arghash)))
	{
	    ##  Place params back into the URL
	    $url .= "?" . join ("&",
				map {join ("=", $_, uri_escape($arghash{$_}))}
				keys (%arghash));

	    ##  Place params into $javascript_init
	    $javascript_init =
	      "connection.initargs = new Object();\n" .
		join (";\n", map
		      {join (" = ",
			     "connection.initargs." . $_,
			     quote_javascript_string($arghash{$_}))}
		      keys (%arghash)) . ";\n";
	};
    };
    if (! ((defined ($url)) ||
	   (defined ($url = $::URLmap->{$dnis})) ||
	   (defined ($url = $::URLmap->{"*"}))))
    {
	($::Loglevel >= LOG_EROR)
	  && logit (LOG_EROR, "No matching URL for DNIS $dnis");
	send_ct_client_msg ($::CTSrvInfo, {Satc::MSGTYPE => Satc::HANGUP,
					   Satc::CALLID => $callid});
	return;
    };

    ##  Create a new descriptor pair to communicate with a new VXML thread
    ($ok, $msg, $perl_fh, $c_fh) =
      Cam::Scom::c_socketpair(AF_UNIX, SOCK_STREAM, PF_UNSPEC);
    if (! $ok)
    {
	($::Loglevel >= LOG_EROR)
	  && logit (LOG_EROR, "Unable to start VXML interpreter" .
		    " on incoming call, failure from socketpair(): $msg");
	send_ct_client_msg ($::CTSrvInfo, {Satc::MSGTYPE => Satc::HANGUP,
					   Satc::CALLID => $callid});
	return;
    };
    $c_fd = $c_fh;
    $fh_spec = {"type" => FHINFO_TYPE_VXML_INTERP,
		"fh" => $perl_fh,
		"host" => "localhost",
		"callid" => $callid,
		"vxml_fd" => $c_fd,
		"connected" => 1,
		"processing" => 0,
		"next_rec_num" => 0};

    ($::Loglevel >= LOG_NOTI)
      && logit (LOG_NOTI, "callid=[" . $callid .
		"] starting VXML interp on url=\"" .
		$url . "\" from ANI=\"" . $ani .
		"\" for DNIS=\"" . $dnis . "\"" .
		" javascript_init=\"" . $javascript_init . "\"" .
		" perlfd=" . $perl_fh .
		" vxmlfd=" . $c_fd .
		" =#[#= " . sprintf ("%.3f", systime()) .
		" call start " . $callid . " =#]#=");

    ##  Start a new VXML thread
    if (! (($ok, $msg, $call_handle) =
	   Vxglue::_start_voiceglue_thread
	   ($::Platform_handle, $callid, $c_fd, $url,
	    $ctmsg->{Satc::ANI}, $ctmsg->{Satc::DNIS},
	    $javascript_init))[0])
    {
	($::Loglevel >= LOG_EROR)
	  && logit (LOG_EROR, "Failure from start_voiceglue_thread: $msg");
	POSIX::close ($perl_fh);
	POSIX::close ($c_fd);
	return;
    };
    $fh_spec->{"call_handle"} = $call_handle;

    ##  Register the filehandle
    if (! (($ok, $msg) = $::Scom->register ("$perl_fh+"))[0])
    {
	($::Loglevel >= LOG_CRIT)
	  && logit (LOG_CRIT, "Failure from Scom->register on $perl_fh: $msg");
	POSIX::close ($perl_fh);
	POSIX::close ($c_fd);
	send_ct_client_msg ($::CTSrvInfo, {Satc::MSGTYPE => Satc::HANGUP,
					   Satc::CALLID => $callid});
	return;
    };

    ##  Place it in $::Clients
    $::Clients->{$perl_fh} = $fh_spec;
    $::Callid_to_vxml_fh->{$callid} = $perl_fh;
    ++$::VXML_threads;
};

##  handle_satc_gotdig ($ctmsg)
##    -- Handles SATC gotdig message in $ctmsg
sub handle_satc_gotdig
{
    my ($ctmsg) = shift (@_);
    my ($callid, $fhinfo, $fh);

    $callid = $ctmsg->{Satc::CALLID};
    if ((! defined ($fh = $::Callid_to_vxml_fh->{$callid})) ||
	(! defined ($fhinfo = $::Clients->{$fh})))
    {
	($::Loglevel >= LOG_NOTI)
	  && logit (LOG_NOTI,
		    "[$callid] Cannot find VXML filehandle, assuming deleted");
	return;
    };

    ##  Check for errors
    if ($ctmsg->{Satc::STATUS} != 0)
    {
	clear_play_and_rec ($fhinfo);
	send_vxml_interp_msg ($fhinfo, join (" ",
					     "Recognized",
					     VXIrec_RESULT_FAILURE,
					     NLSML_NOINPUT));
	return;
    };

    if ($ctmsg->{Satc::REASON} == Satc::GOTDIGIT_REASON_TIMEOUT)
    {
	$fhinfo->{"timed_out"} = 1;
    }
    else
    {
	##  Accumulate new digits
	defined ($fhinfo->{"got_dtmf"}) || ($fhinfo->{"got_dtmf"} = "");
	if ((length ($fhinfo->{"termchar"}) == 1) &&
	    (length ($ctmsg->{"digits"}) == 1) &&
	    ($fhinfo->{"termchar"} eq $ctmsg->{"digits"}))
	{
	    ##  Got a terminator character
	    $fhinfo->{"got_termchar"} = 1;
	}
	else
	{
	    $fhinfo->{"got_dtmf"} .= $ctmsg->{"digits"};
	};
    };

    do_prompt_and_listen ($fhinfo);
};

##  handle_satc_transfered ($ctmsg)
##    -- Handles SATC transfered message in $ctmsg
sub handle_satc_transfered
{
    my ($ctmsg) = shift (@_);
    my ($callid, $fhinfo, $fh);

    $callid = $ctmsg->{Satc::CALLID};
    if ((! defined ($fh = $::Callid_to_vxml_fh->{$callid})) ||
	(! defined ($fhinfo = $::Clients->{$fh})))
    {
	($::Loglevel >= LOG_NOTI)
	  && logit (LOG_NOTI,
		    "[$callid] Cannot find VXML filehandle, assuming deleted");
	return;
    };

    ##  This must be in response to a vxml Transfer, so return the result
    send_vxml_interp_msg ($fhinfo, "Transfered");
};

##  handle_satc_recorded ($ctmsg)
##    -- Handles SATC recorded message in $ctmsg
sub handle_satc_recorded
{
    my ($ctmsg) = shift (@_);
    my ($callid, $fh, $fhinfo);
    my ($result, $reason, $duration, $digit, $path, @statinfo);

    $callid = $ctmsg->{Satc::CALLID};
    $result = (($ctmsg->{Satc::STATUS} == 0) ? VXIrec_RESULT_SUCCESS
	       : VXIrec_RESULT_FAILURE);
    $reason = $ctmsg->{Satc::REASON};
    $duration = $ctmsg->{Satc::DURATION};
    $digit = $ctmsg->{Satc::DIGITS};
    defined ($digit) && length ($digit) || ($digit = "-");

    ##  See if channel is now gone
    if ((! defined ($fh = $::Callid_to_vxml_fh->{$callid})) ||
	(! defined ($fhinfo = $::Clients->{$fh})))
    {
	($::Loglevel >= LOG_NOTI)
	  && logit (LOG_NOTI,
		    "[$callid] Cannot find VXML filehandle, assuming deleted");
	return;
    };

    $path = $fhinfo->{"rec_file"};
    clear_play_and_rec ($fhinfo);

    if ($ctmsg->{Satc::STATUS} != 0)
    {
	($::Loglevel >= LOG_NOTI)
	  && logit (LOG_NOTI,
		    "[$callid] Failure from record: " . $ctmsg->{Satc::MSG});
    };

    ##  Return result to ovxi
    send_vxml_interp_msg ($fhinfo, join (" ", "Recorded", $result,
					 $reason, $duration, $digit,
					 $path));
};

##  handle_satc_played ($ctmsg)
##    -- Handles SATC played message in $ctmsg
sub handle_satc_played
{
    my ($ctmsg) = shift (@_);
    my ($callid, $fh, $fhinfo);

    $callid = $ctmsg->{Satc::CALLID};
    if ((! defined ($fh = $::Callid_to_vxml_fh->{$callid}) ||
	(! defined ($fhinfo = $::Clients->{$fh}))))
    {
	($::Loglevel >= LOG_NOTI)
	  && logit (LOG_NOTI,
		    "[$callid] Cannot find VXML filehandle, assuming deleted");
	return;
    };

    do_prompt_and_listen ($fhinfo);
};

##  handle_satc_playeddig ($ctmsg)
##    -- Handles SATC playeddig message in $ctmsg
sub handle_satc_playeddig
{
    my ($ctmsg) = shift (@_);
    my ($callid, $fh, $fhinfo);

    $callid = $ctmsg->{Satc::CALLID};
    if ((! defined ($fh = $::Callid_to_vxml_fh->{$callid}) ||
	(! defined ($fhinfo = $::Clients->{$fh}))))
    {
	($::Loglevel >= LOG_NOTI)
	  && logit (LOG_NOTI,
		    "[$callid] Cannot find VXML filehandle, assuming deleted");
	return;
    };

    do_prompt_and_listen ($fhinfo);
};

##  handle_satc_returnedvar ($ctmsg)
##    -- Handles SATC returnedvar message in $ctmsg
sub handle_satc_returnedvar
{
    my ($ctmsg) = shift (@_);
    my ($callid, $fhinfo, $fh);

    $callid = $ctmsg->{Satc::CALLID};
    if ((! defined ($fh = $::Callid_to_vxml_fh->{$callid})) ||
	(! defined ($fhinfo = $::Clients->{$fh})))
    {
	($::Loglevel >= LOG_NOTI)
	  && logit (LOG_NOTI,
		    "[$callid] Cannot find VXML filehandle, assuming deleted");
	return;
    };

    ##  This must be in response to a vxml extival, so return the confirmation.
    send_vxml_interp_msg ($fhinfo, "exitedval");
};

##  handle_satc_hungup_or_released ($ctmsg)
##    -- Handles SATC hungup or released message in $ctmsg
sub handle_satc_hungup_or_released
{
    my ($ctmsg) = shift (@_);
    my ($callid, $fh, $fhinfo, $vxml_cmd);

    $callid = $ctmsg->{Satc::CALLID};
    if (defined ($fh = $::Callid_to_vxml_fh->{$callid}))
    {
	if (defined ($fhinfo = $::Clients->{$fh}))
	{
	    delete $fhinfo->{"connected"};
	    ##  If a vxml interpreter is awaiting a result, it
	    ##  must now be responsed to.
	    ##  Could be one of:  Wait, Recognize, Transfer
	    if (defined ($vxml_cmd = $fhinfo->{"vxml_doing"}))
	    {
		if ($vxml_cmd == OVXI_WAIT)
		{
		    send_vxml_interp_msg ($fhinfo, "Waited");
		}
		elsif ($vxml_cmd == OVXI_RECOGNIZE)
		{
		    send_vxml_interp_msg ($fhinfo,
					  "Recognized 0 " . NLSML_NOINPUT);
		}
		elsif ($vxml_cmd == OVXI_TRANSFER)
		{
		    send_vxml_interp_msg ($fhinfo, "Transfered");
		}
		elsif ($vxml_cmd == OVXI_RECORD)
		{
		    send_vxml_interp_msg ($fhinfo, "Recorded");
		};
	    };
	};
    };
};

##  handle_msg_from_ct_server ($ctinfo, $bytes)
##    -- Handles new message in $bytes coming from CT server
##       described by $ctinfo
sub handle_msg_from_ct_server
{
    my ($ctinfo) = shift (@_);
    my ($bytes) = shift (@_);
    my ($ok, $errmsg, $msg, $ctmsg);
    my ($type, $callid, $url, $load, $total, $regs, $agiinfo);
    my ($vxml_fh, $vxmlinfo);

    if ($::Loglevel >= LOG_DBUG)
    {
	logit (LOG_DBUG, "rcv ctsrv: " . dump_bytes ($bytes));
    };

    ##  First, parse it into its fields
    chop ($bytes);
    (substr ($bytes, -1) eq "\r") && chop ($bytes);
    if (! (($ok, $errmsg, $ctmsg) = $::Satc->decode ($bytes))[0])
    {
	($::Loglevel >= LOG_EROR)
	  && logit (LOG_EROR, $errmsg . " from " .
		    describe_fh ($ctinfo->{"fh"}) . " in msg " .
		    dump_bytes ($bytes));
	return;
    };

    $callid = $ctmsg->{Satc::CALLID};
    ($::Loglevel >= LOG_DBUG)
      && logit (LOG_DBUG,
		(defined ($callid) ? "callid=[" . $callid . "] " : "") .
		"parsed " . $::Satc->describe_msg ($ctmsg));

    ##  Update satc_doing
    if (defined ($callid) &&
	defined ($vxml_fh = $::Callid_to_vxml_fh->{$callid}))
    {
	$vxmlinfo = $::Clients->{$vxml_fh};
	delete $vxmlinfo->{"satc_doing"};
    };

    ##  Now, branch based on message type
    $type = $ctmsg->{Satc::MSGTYPE};
    if ($type == Satc::INCOMING)
    {
	handle_satc_incoming ($ctmsg);
    }
    elsif ($type == Satc::GOTDIG)
    {
	handle_satc_gotdig ($ctmsg);
    }
    elsif ($type == Satc::PLAYED)
    {
	handle_satc_played ($ctmsg);
    }
    elsif ($type == Satc::PLAYEDDIG)
    {
	handle_satc_playeddig ($ctmsg);
    }
    elsif (($type == Satc::HUNGUP) ||
	   ($type == Satc::RELEASED))
    {
	handle_satc_hungup_or_released ($ctmsg);
    }
    elsif ($type == Satc::TRANSFERED)
    {
	handle_satc_transfered ($ctmsg);
    }
    elsif ($type == Satc::RECORDED)
    {
	handle_satc_recorded ($ctmsg);
    }
    elsif ($type == Satc::STOPPEDIN)
    {
	##  No action necessary
    }
    elsif ($type == Satc::STOPPED)
    {
	##  No action necessary
    }
    elsif ($type == Satc::RETURNEDVAR)
    {
	handle_satc_returnedvar ($ctmsg);
    }
    else
    {
	($::Loglevel >= LOG_EROR)
	  && logit (LOG_EROR, "Unsupported msg " .
		    $::Satc->describe_msg ($ctmsg) .
		    " from " .
		    describe_fh ($ctinfo->{"fh"}));
    };
};

##  send_vxml_interp_msg ($fhinfo, $ovxi_msg)
##    -- Sends $ovxi_msg to the vxml interpreter at fd described by $fhinfo
sub send_vxml_interp_msg
{
    my ($fhinfo) = shift (@_);
    my ($bytes) = shift (@_);
    my ($callid);
    my ($loglevel) = LOG_DBUG;

    ##  Update vxml_doing
    delete $fhinfo->{"vxml_doing"};

    ##  Send it off, logging "Recognized" messages a little higher
    $callid = $fhinfo->{"callid"};
    ($bytes =~ /^Recognized /) && ($loglevel = LOG_INFO);
    ($::Loglevel >= $loglevel)
      && logit ($loglevel, (defined ($callid) ?
			    ("callid=[" . $callid . "] ") : "")
		. "snd " . $bytes .
		" to "  . describe_fh ($fhinfo->{"fh"}));

    $bytes .= "\n";
    send_bytes ($fhinfo, $bytes);
};

##  clear_play_and_rec ($fhinfo);
##    -- Clears out all variables associated with the current
##       play and rec session
sub clear_play_and_rec
{
    my ($fhinfo) = shift (@_);
    my ($callid);

    $callid = $fhinfo->{"callid"};
    if ($::Loglevel >= LOG_DBUG)
    {
	logit (LOG_DBUG, "callid=[" . $callid .
	       "] dpal() Data Cleared");
    };
    delete $fhinfo->{"play_queued"};
    delete $fhinfo->{"play_requested"};
    delete $fhinfo->{"wait_requested"};
    delete $fhinfo->{"recognize_requested"};
    delete $fhinfo->{"record_requested"};
    delete $fhinfo->{"got_dtmf"};
    delete $fhinfo->{"rec_timeout"};
    delete $fhinfo->{"rec_maxtime"};
    delete $fhinfo->{"rec_dtmfterm"};
    delete $fhinfo->{"record_tone"};
    delete $fhinfo->{"rec_file"};
    delete $fhinfo->{"timed_out"};
    delete $fhinfo->{"got_termchar"};
};

##  $signals = active_signals ($fhinfo);
##    -- Returns string of signal characters for all currently active grammars.
##       Returns "" if no signals are currently requested in active grammars.
sub active_signals
{
    my ($fhinfo) = shift (@_);
    my ($signals, $input, @active_gramids, @active_rules);
    my ($match, $interp, $rule);

    ##  See if cached value is available
    defined ($signals = $fhinfo->{"gram_signals"}) && return $signals;

    ##  Have to compute new signals
    @active_gramids = grep ($fhinfo->{"gram_ids"}{$_}{"active"} == 1,
			    keys (%{$fhinfo->{"gram_ids"}}));
    @active_rules = map ($fhinfo->{"gram_ids"}{$_}{"rule"},
			 @active_gramids);
    $signals = "";
    foreach $input ("h", "m", "t")
    {
	($match, $interp, $rule) =
	  SRGSDTMF::check_rules_match ($input, @active_rules);
	if ($match >= 0)
	{
	    $signals .= $input;
	};
    };
    $fhinfo->{"gram_signals"} = $signals;
    return $signals;
}

##  get_one_digit ($fhinfo, $timeout)
##    --  Initiates a single-digit get from the Satc server.
##        Uses $timeout as ms timeout.
sub get_one_digit
{
    my ($fhinfo) = shift (@_);
    my ($timeout) = shift (@_);
    my ($callid) = $fhinfo->{"callid"};
    my ($active_signals) = active_signals ($fhinfo);
    my ($satc_command);

    $satc_command = {Satc::MSGTYPE => Satc::GETDIG,
		     Satc::CALLID => $callid,
		     Satc::TIMEOUT => $timeout,
		     Satc::STOPKEYS => "0123456789*#" . $active_signals,
		     Satc::MAX_DIG => 1};
    send_ct_client_msg ($::CTSrvInfo, $satc_command);
};

##  do_prompt_and_listen ($fhinfo)
##    -- Given VXML filehandle structure $fhinfo,
##       attempts to start or continue playing prompts, recognizing,
##       and/or recording based on the contents of the channel variables.
sub do_prompt_and_listen
{
    my ($fhinfo) = shift (@_);
    my ($callid, $queue, $satc_command, $index, $total, $status);
    my ($file, $digits, @active_gramids, @active_rules);
    my ($match, $interp, $rule, $nlsml, $gram_id, $rec_format, @gram_ids);
    my ($could_queue_more, $bargein_for_batch, @filelist);
    my ($queueitem, $type, $dtmfstring);

    $callid = $fhinfo->{"callid"};

    if ($::Loglevel >= LOG_DBUG)
    {
	logit (LOG_DBUG, "callid=[" . $callid .
	       "] dpal(): do_prompt_and_listen() called");
    };

    ##  First, see if something is already happening on telphony, in which
    ##  case there is no point in continuing here.
    if (defined ($fhinfo->{"satc_doing"}))
    {
	if ($::Loglevel >= LOG_DBUG)
	{
	    logit (LOG_DBUG, "callid=[" . $callid .
		   "] dpal(): satc_doing " .
		   $::Satc->describe_msgtype ($fhinfo->{"satc_doing"}) .
		   ", returning");
	};
	return;
    };

    ##  See if timeout with no input
    if ((defined ($fhinfo->{"timed_out"})) &&
	(! defined ($fhinfo->{"got_dtmf"})))
    {
	##  Empty input timeout
	if ($::Loglevel >= LOG_DBUG)
	{
	    logit (LOG_DBUG, "callid=[" . $callid .
		   "] dpal(): empty input timeout, returning NOINPUT");
	};
	clear_play_and_rec ($fhinfo);
	send_vxml_interp_msg ($fhinfo, join (" ",
					     "Recognized",
					     VXIrec_RESULT_SUCCESS,
					     NLSML_NOINPUT));
	return;
    };

    ##  If keys have started to be pressed, see if we need to
    ##  continue, or if a match has been found to a DTMF grammar.
    if (defined ($fhinfo->{"got_dtmf"}))
    {
	##  Check the input against all DTMF grammars
	$digits = $fhinfo->{"got_dtmf"};
	@active_gramids = grep ($fhinfo->{"gram_ids"}{$_}{"active"} == 1,
				keys (%{$fhinfo->{"gram_ids"}}));
	@active_rules = map ($fhinfo->{"gram_ids"}{$_}{"rule"},
			     @active_gramids);
	if ($::Loglevel >= LOG_DBUG)
	{
	    logit (LOG_DBUG, "callid=[" . $callid .
		   "] dpal(): DTMFs received = \"" .
		   $digits .
		   "\", trying to match against " .
		   scalar (@active_rules) .
		   " active grammar(s)");
	};
	($match, $interp, $rule) =
	  SRGSDTMF::check_rules_match ($digits, @active_rules);
	if ($::Loglevel >= LOG_DBUG)
	{
	    logit (LOG_DBUG, "callid=[" . $callid .
		   "] dpal(): check_rules_match returns " .
		   $match . " = " .
		   (($match == -1) ? "failed match"
		    : ($match == 0) ? "partial match"
		    : ($match == 1) ? "full match with more match possible"
		    : ($match == 2) ? "full match with no further possible"
		    : "unknown"));
	};

	if (
	    (($match == 2) && (($fhinfo->{"termtimeout"} == 0) ||
			       (length ($fhinfo->{"terchar"}) == 0) ||
			       defined ($fhinfo->{"timed_out"}) ||
			       defined ($fhinfo->{"got_termchar"})))
	     ||
	    (($match == 1) && (defined ($fhinfo->{"timed_out"}) ||
			       defined ($fhinfo->{"got_termchar"})))
	   )
	{
	    ##  Return a match, so stop prompt/rec and return the result
	    if ($::Loglevel >= LOG_DBUG)
	    {
		logit (LOG_DBUG, "callid=[" . $callid .
		       "] dpal(): DTMFs matched, sending result");
	    };

	    clear_play_and_rec ($fhinfo);
	    @gram_ids = keys(%{$fhinfo->{"gram_texts"}{$rule->{"text"}}});
	    @gram_ids = grep ($fhinfo->{"gram_ids"}{$_}{"active"}, @gram_ids);
	    $gram_id = $gram_ids[0];
	    defined ($interp) || ($interp = "");
	    $nlsml = "<?xml version=\'1.0\'?> <result> <interpretation grammar=\"$gram_id\" confidence=\"100\"> <input mode=\"dtmf\">$digits</input> <instance>$interp</instance> </interpretation> </result>";
	    send_vxml_interp_msg ($fhinfo, join (" ",
						 "Recognized",
						 VXIrec_RESULT_SUCCESS,
						 $nlsml));
	    return;
	}
	elsif ($match == 2)
	{
	    ##  Have to wait for termchar
	    if ($::Loglevel >= LOG_DBUG)
	    {
		logit (LOG_DBUG, "callid=[" . $callid .
		       "] dpal(): DTMFs awaiting termchar");
	    };
	    get_one_digit ($fhinfo, $fhinfo->{"termtimeout"});
	    return;
	}
	elsif (defined ($fhinfo->{"timed_out"}) ||
	       defined ($fhinfo->{"got_termchar"}) ||
	       ($match == -1))
	{
	    ##  Failed match
	    if ($::Loglevel >= LOG_DBUG)
	    {
		logit (LOG_DBUG, "callid=[" . $callid .
		       "] dpal(): DTMFs failed match, sending result");
	    };

	    clear_play_and_rec ($fhinfo);
	    send_vxml_interp_msg ($fhinfo, join (" ",
						 "Recognized",
						 VXIrec_RESULT_SUCCESS,
						 NLSML_NOMATCH));
	    return;
	}
	else
	{
	    ##  No match yet, so keep listening for digits
	    if ($::Loglevel >= LOG_DBUG)
	    {
		logit (LOG_DBUG, "callid=[" . $callid .
		       "] dpal(): DTMFs getting further input");
	    };
	    get_one_digit ($fhinfo, $fhinfo->{"interdigittimeout"});
	    return;
	};
    };


    ##  Determine if there are any prompts to start playing
    if (defined ($fhinfo->{"play_requested"}))
    {
	##  Check down the list of prompts to play
	if ($::Loglevel >= LOG_DBUG)
	{
	    logit (LOG_DBUG, "callid=[" . $callid .
		   "] dpal(): Checking for prompts");
	};
	undef $bargein_for_batch;
	@filelist = ();
	if (defined ($queue = $fhinfo->{"play_queued"}) &&
	    ($total = scalar (@$queue)))
	{
	    $could_queue_more = 1;
	    $index = -1;
	    while ($could_queue_more && (++$index < $total))
	    {
		$queueitem = $queue->[$index];
		$status = $queueitem->{"status"};
		$type = $queueitem->{"type"};
		if (($type eq "dtmf") && ($status == 1))
		{
		    ##  Can always play DTMFs at beginning of queue,
		    ##  but can't combine them with audio.
		    if (! scalar (@filelist))
		    {
			##  Play these DTMFs now
			$dtmfstring = $queueitem->{"path"};
			$queueitem->{"status"} = 2;
		    }
		    ##  Can't proceed further as DTMFs don't mix with audio
		    $could_queue_more = 0;
		}
		elsif ($status == 0)
		{
		    ##  Can't proceed further - awaiting soundcache creation
		    $could_queue_more = 0;
		}
		elsif ($status == 1)
		{
		    ##  Make sure the bargein setting doesn't conflict
		    ##  with the prompts already in the list
		    if ((! defined ($bargein_for_batch)) ||
			($bargein_for_batch == $queueitem->{"bargein"}))
		    {
			##  Queue it up
			push (@filelist, $queueitem->{"path"});
			$bargein_for_batch = $queueitem->{"bargein"};
			$queueitem->{"status"} = 2;
		    }
		    else
		    {
			##  Can't mix bargein and non-bargein, must wait
			$could_queue_more = 0;
		    };
		};
	    };

	    ##  Play DTMFs or audio if they're ready
	    if (defined ($dtmfstring))
	    {
		if ($::Loglevel >= LOG_DBUG)
		{
		    logit (LOG_DBUG, "callid=[" . $callid .
			   "] dpal(): Found DTMFs to play, playing");
		};
		if ($index == $total)
		{
		    ##  Got to the end of the list, so done playing
		    ##  as soon as these play
		    delete $fhinfo->{"play_requested"};
		    delete $fhinfo->{"play_queued"};
		};
		$satc_command = {Satc::MSGTYPE => Satc::PLAYDIG,
				 Satc::CALLID => $callid,
				 Satc::DIGITS => $dtmfstring};
		send_ct_client_msg ($::CTSrvInfo, $satc_command);
		return;
	    }
	    elsif (scalar (@filelist))
	    {
		if ($::Loglevel >= LOG_DBUG)
		{
		    logit (LOG_DBUG, "callid=[" . $callid .
			   "] dpal(): Found prompts to play, playing");
		};
		if ($index == $total)
		{
		    ##  Got to the end of the list, so done playing
		    ##  as soon as these play
		    delete $fhinfo->{"play_requested"};
		    delete $fhinfo->{"play_queued"};
		};
		$satc_command = {Satc::MSGTYPE => Satc::PLAY,
				 Satc::CALLID => $callid,
				 Satc::FILES => [ @filelist ],
				 Satc::STOPKEYS =>
				 ($bargein_for_batch ?
				  "0123456789*#" . active_signals ($fhinfo)
				  : "")};
		send_ct_client_msg ($::CTSrvInfo, $satc_command);
		return;
	    };

	    ##  See if we got to the end of the list
	    if ($index != $total)
	    {
		##  Didn't get to the end of the list, so keep waiting
		if ($::Loglevel >= LOG_DBUG)
		{
		    logit (LOG_DBUG, "callid=[" . $callid .
			   "] dpal(): No prompts ready, waiting for more");
		};
		return;
	    }
	    else
	    {
		##  Got to end of list, so no more to play
		if ($::Loglevel >= LOG_DBUG)
		{
		    logit (LOG_DBUG, "callid=[" . $callid .
			   "] dpal(): Done with prompts");
		};
		delete $fhinfo->{"play_queued"};
		delete $fhinfo->{"play_requested"};
	    };
	}
	else
	{
	    ##  No prompts to play
	    if ($::Loglevel >= LOG_DBUG)
	    {
		logit (LOG_DBUG, "callid=[" . $callid .
		       "] dpal(): Done with prompts");
	    };
	    delete $fhinfo->{"play_queued"};
	    delete $fhinfo->{"play_requested"};
	};
    };

    ##  No more prompts to process, so let's see if this was a wait
    if (defined ($fhinfo->{"wait_requested"}))
    {
	##  A wait was requested, so return a result
	if ($::Loglevel >= LOG_DBUG)
	{
	    logit (LOG_DBUG, "callid=[" . $callid .
		   "] dpal(): Sending response to wait");
	};
	clear_play_and_rec ($fhinfo);
	##  Respond immediately
	send_vxml_interp_msg ($fhinfo, "Waited");
	return;
    };

    ##  No more prompts or wait, so let's see about a rec
    if (defined ($fhinfo->{"recognize_requested"}))
    {
	##  Have to do a recognition
	if ($::Loglevel >= LOG_DBUG)
	{
	    logit (LOG_DBUG, "callid=[" . $callid .
		   "] dpal(): Starting recognition");
	};
	get_one_digit ($fhinfo, $fhinfo->{"rec_timeout"});
	return;
    };

    ##  No more prompts or wait or recognition, so let's see about a record
    if (defined ($fhinfo->{"record_requested"}))
    {
	##  Have to do a record
	if ($::Loglevel >= LOG_DBUG)
	{
	    logit (LOG_DBUG, "callid=[" . $callid .
		   "] dpal(): Starting record");
	};
	$rec_format = (($fhinfo->{"rec_type"} =~ /alaw/) ? "alaw" : "ulaw");
	$file = join ("/", $::AstSoundPrefix, "rec",
		      join ("_", $$, $callid, "rec")) . "." . $rec_format;
	$fhinfo->{"rec_file"} = join ("/", $::VgSoundDir, "rec",
				      join ("_", $$, $callid, "rec")) .
					"." . $rec_format;
	$satc_command =
	{Satc::MSGTYPE => Satc::RECORD,
	 Satc::CALLID => $callid,
	 Satc::FILE => $file,
	 Satc::START_TONE => ($fhinfo->{"record_tone"} ? "tone" : "notone"),
	 Satc::TIMEOUT => $fhinfo->{"rec_finalsilence"},
	 Satc::MAX_TIME => $fhinfo->{"rec_maxtime"},
	 Satc::STOPKEYS => ($fhinfo->{"rec_dtmfterm"} ?
			    "0123456789*#" . active_signals ($fhinfo) : ""),
	 Satc::MIX => "inbound"};
	send_ct_client_msg ($::CTSrvInfo, $satc_command);
	return;
   };

    if ($::Loglevel >= LOG_DBUG)
    {
	logit (LOG_DBUG, "callid=[" . $callid .
	       "] dpal(): Nothing found to do");
    };
};

##  ($ok, $msg, $xlation) = translate_builtin ($builtin_grammar)
##    -- Returns $xlation the translation of a builtin grammar.
sub translate_builtin
{
    my ($builtin_grammar) = shift (@_);
    my ($base, $remainder, $gram_args, @arg_items);
    my ($min, $max, $arg, $value, $xlation, $var_start, $var_end);

    $gram_args = {};
    if ($builtin_grammar =~ /^([^\?]+)\?(.+)$/)
    {
	$base = $1;
	$remainder = $2;
	@arg_items = split (/;/, $remainder);
	foreach $remainder (@arg_items)
	{
	    if ($remainder =~ /^([^=]+)=(.+)$/)
	    {
		$gram_args->{$1} = $2;
	    }
	    else
	    {
		return (0, "Bad argument \"" . $remainder . "\"");
	    };
	};
    }
    else
    {
	$base = $builtin_grammar;
    };

    if ($base eq "digits")
    {
	##  Check arguments
	foreach $arg (keys (%$gram_args))
	{
	    $value = $gram_args->{$arg};
	    if ($arg eq "length")
	    {
		($value =~ /^\d+$/)
		  || return (0, "Bad length parameter");
		((defined ($min) && ($min != $value)) ||
		 (defined ($max) && ($max != $value)))
		  && return (0, "Conflicting length parameters");
		$min = $value;
		$max = $value;
	    }
	    elsif ($arg eq "minlength")
	    {
		($value =~ /^\d+$/)
		  || return (0, "Bad minlength parameter");
		(defined ($min) && ($min != $value))
		  && return (0, "Conflicting length parameters");
		$min = $value
	    }
	    elsif ($arg eq "maxlength")
	    {
		($value =~ /^\d+$/)
		  || return (0, "Bad maxlength parameter");
		(defined ($max) && ($max != $value))
		  && return (0, "Conflicting length parameters");
		$max = $value;
	    };
	};
	defined ($min) && defined ($max) && ($min > $max)
	  && return (0, "Conflicting length parameters");

	##  Generate the translation
	defined ($min) || defined ($max) || ($min = 1);
	defined ($min) || ($min = "1");
	defined ($max) || ($max = "30000");
	$var_start = "<item repeat=\"$min-$max\">";
	$var_end = "</item>";
	$xlation = "<rule id=\"digit\" scope=\"public\">
 $var_start
  <one-of>
    <item> 0 </item>
    <item> 1 </item>
    <item> 2 </item>
    <item> 3 </item>
    <item> 4 </item>
    <item> 5 </item>
    <item> 6 </item>
    <item> 7 </item>
    <item> 8 </item>
    <item> 9 </item>
  </one-of>
 $var_end
</rule>
";
	return (1, "", $xlation);
    }
    else
    {
	return (0, "Builtin \"$base\" not supported");
    };
};

##  ($ok, $msg, $xlation) = translate_choice ($grammar_text);
##    -- Returns $xlation the translation of a choice grammar.
sub translate_choice
{
    my ($grammar_text) = shift (@_);
    my ($xlation, $item, $items_found, @items);

    ##  Generate the translation
    @items = split (//, $grammar_text);
    $items_found = 0;
    $xlation = "<rule id=\"$grammar_text\" scope=\"public\">\n";
    foreach $item (@items)
    {
	if ($item !~ /^\s*$/)
	{
	    ++ $items_found;
	    $xlation .= "  <item> $item </item>\n"
	};
    };
    $xlation .= "</rule>\n";
    if (! $items_found)
    {
	return (0, "No items found in choice grammar \"$grammar_text\"");
    };
    return (1, "", $xlation);
};

##  handle_ovxi_play ($fh_spec, $ovximsg)
##    -- Handles "play" message in $ovxi_msg from OVXI for VXML
##       interpreter specified by $fh_spec
sub handle_ovxi_play
{
    my ($fhinfo) = shift (@_);
    my ($ovximsg) = shift (@_);

    $fhinfo->{"play_requested"} = 1;
    ##  Don't actually start the play.
    ##  The actual play will start on a subsequent
    ##  recognize, record, or wait message.
    send_vxml_interp_msg ($fhinfo, "Played");
};

##  handle_ovxi_wait ($fh_spec, $ovximsg)
##    -- Handles "wait" message in $ovxi_msg from OVXI for VXML
##       interpreter specified by $fh_spec
sub handle_ovxi_wait
{
    my ($fhinfo) = shift (@_);
    my ($ovximsg) = shift (@_);
    my ($callid, $cmd);

    $callid = $fhinfo->{"callid"};
    if (! defined ($fhinfo->{"connected"}))
    {
	send_vxml_interp_msg ($fhinfo, "Waited");
	return;
    };

    ##  If a play has been requested and there are files to
    ##  play, we have to play them (no bargein assumed)
    ##  Update vxml_doing
    if ((defined ($fhinfo->{"play_requested"})) &&
	(defined ($fhinfo->{"play_queued"})))
    {
	$fhinfo->{"vxml_doing"} = $ovximsg->{"msgtype"};
	$fhinfo->{"wait_requested"} = 1;
	do_prompt_and_listen ($fhinfo);
    }
    else
    {
	##  Return immediately
	send_vxml_interp_msg ($fhinfo, "Waited");
	return;
    };
};

##  handle_ovxi_builtin ($fh_spec, $ovximsg)
##    -- Handles "builtin" message in $ovxi_msg from OVXI for VXML
##       interpreter specified by $fh_spec
sub handle_ovxi_builtin
{
    my ($fhinfo) = shift (@_);
    my ($ovximsg) = shift (@_);
    my ($callid, $grammar, $length, $min_length, $max_length);

    $callid = $fhinfo->{"callid"};
    $grammar = $ovximsg->{"grammar"};

    ##  There are two types of translation:
    ##    Fixed-length digits:  "builtin:.../digits?length=XX"
    ##      translate to: "00XX"
    ##    Var-length digits:  "builtin:.../digits?minlength=XX&maxlength=YY"
    ##                   or:  "builtin:.../digits?maxlength=YY"
    ##      translate to: "00XXm0YY"

    if ($grammar =~ /^builtin:[^\/]*\/digits\?length=(\d+)$/)
    {
	##  Fixed-length digit string
	$length = $1;
	$grammar = "00$length";
    }
    elsif ($grammar =~ /^builtin:[^\/]*\/digits\?minlength=(\d+).*maxlength=(\d+)$/)
    {
	##  Var-length digit string
	$min_length = $1;
	$max_length = $2;
	$grammar = join ("m", "00$min_length", "0$max_length");
    }
    elsif ($grammar =~ /^builtin:[^\/]*\/digits\?maxlength=(\d+)$/)
    {
	##  Var-length digit string
	$min_length = 0;
	$max_length = $1;
	$grammar = join ("m", "0$min_length", "0$max_length");
    }
    else
    {
	($::Loglevel >= LOG_WARN)
	  && logit (LOG_WARN, "callid=[" . $callid .
		    "] has unrecognized builtin grammar \"" .
		    $grammar .
		    "\", assuming generic #-termination");
	$grammar = "001m032";
    };
    send_vxml_interp_msg ($fhinfo, join (" ", "Grammar", $grammar));
}

##  handle_ovxi_getlinestatus ($fh_spec, $ovximsg)
##    -- Handles "GetLineStatus" message in $ovxi_msg from OVXI for VXML
##       interpreter specified by $fh_spec
sub handle_ovxi_getlinestatus
{
    my ($fhinfo) = shift (@_);
    my ($ovximsg) = shift (@_);
    my ($status);

    $status = (defined ($fhinfo->{"connected"}) ? 1 : 0);
    send_vxml_interp_msg ($fhinfo, "LineStatus " . $status);
}

##  handle_ovxi_disconnect ($fh_spec, $ovximsg)
##    -- Handles "Disconnect" message in $ovxi_msg from OVXI for VXML
##       interpreter specified by $fh_spec
sub handle_ovxi_disconnect
{
    my ($fhinfo) = shift (@_);
    my ($ovximsg) = shift (@_);
    my ($callid);

    $callid = $fhinfo->{"callid"};
    (defined ($fhinfo->{"connected"})) || return;
    ($::Loglevel >= LOG_NOTI)
      && logit (LOG_NOTI, "callid=[" . $callid .
		"] hanging up on request from VXML interp");
    send_ct_client_msg
      ($::CTSrvInfo, {Satc::MSGTYPE => Satc::HANGUP, Satc::CALLID => $callid});
    delete $fhinfo->{"connected"};
}

##  handle_ovxi_queue ($fh_spec, $ovximsg)
##    -- Handles "queue" message in $ovxi_msg from OVXI for VXML
##       interpreter specified by $fh_spec
sub handle_ovxi_queue
{
    my ($fhinfo) = shift (@_);
    my ($ovximsg) = shift (@_);
    my ($callid, $speak_spec, $ok, $msg, $files, $spoken_texts, $filelist);
    my ($i, $file, $speak_list, $spec, $request_id, $sc_request, $sc_options);
    my (@sc_request_items, @sc_request_options);
    my ($index, $cookie_list, $cookie_item, @sc_cookie_items, $sc_cookies);
    my ($bargein_spec, $bargein_value, $dtmfstring);

    $callid = $fhinfo->{"callid"};

    ##  Parse out the SSML
    $speak_spec = $ovximsg->{"speak_spec"};
    if (! (($ok, $msg, $speak_list)
	   = parse_speak_xml ($speak_spec))[0])
    {
	($::Loglevel >= LOG_EROR)
	  && logit (LOG_EROR, "callid=[" . $callid .
		    "] has bad speak/audio XML in " .
		    $speak_spec .
		    ": " . $msg);
	return;
    };

    ##  Parse out the bargein setting
    $bargein_spec = $ovximsg->{"bargein"};
    $bargein_value = 1;
    if ($bargein_spec eq "false") {$bargein_value = 0;};

    ##  Parse out the cookies
    if (! ((($ok, $msg, $cookie_list) =
	    Satc::_parse_SATC_fields ($ovximsg->{"cookies"}))[0]))
    {
	($::Loglevel >= LOG_EROR)
	  && logit (LOG_EROR, "callid=[" . $callid .
		    "] has unparseable cookies \"" .
		    $ovximsg->{"cookies"} .
		    "\" : " . $msg);
	$sc_cookies = "-";
    }
    elsif (scalar (@$cookie_list))
    {
	@sc_cookie_items = ();
	while (defined ($cookie_item = shift (@$cookie_list)))
	{
	    push (@sc_cookie_items,
		  join ("=", escape_cookie ($cookie_item),
			escape_cookie (shift (@$cookie_list))));
	};
	$sc_cookies = join ("%%", @sc_cookie_items);
    }
    else
    {
	$sc_cookies = "-";
    };

    ##  Process each SSML audio item
    foreach $spec (@$speak_list)
    {
	##  Convert item into a sound cache request unless it's DTMF to play
	$request_id = $::Next_screquest_id;
	(++$::Next_screquest_id >= 10000) && ($::Next_screquest_id = 1000);
	@sc_request_options = ();
	if (defined ($spec->{"tts"}) && defined ($spec->{"url"}))
	{
	    ##  Is a url with a tts fallback
	    push (@sc_request_options, "f");
	};
	if (defined ($spec->{"timeout"}))
	{
	    push (@sc_request_options, "t=" . $spec->{"timeout"});
	};
	if (defined ($spec->{"maxage"}))
	{
	    push (@sc_request_options, "age=" . $spec->{"maxage"});
	};
	if (defined ($spec->{"lang"}))
	{
	    push (@sc_request_options, "lang=" . $spec->{"lang"});
	};
	if (scalar (@sc_request_options))
	{
	    $sc_options = join (":", @sc_request_options);
	}
	else
	{
	    $sc_options = "-";
	};

	##  Check for DTMF play request
	if (defined ($spec->{"tts"}) && (! defined ($spec->{"url"})) &&
	    ($spec->{"tts"} =~ /^DTMF-([0-9#*]+)$/))
	{
	    $dtmfstring = $1;

	    ##  Don't make soundcache request for DTMF plays, place
	    ##  them in the "play_queued" array as status=1 (ready to play)
	    if (! defined ($fhinfo->{"play_queued"}))
	    {
		$fhinfo->{"play_queued"} = [];
	    };
	    $index = scalar (@{$fhinfo->{"play_queued"}});
	    push (@{$fhinfo->{"play_queued"}}, {"status" => 1,
						"type" => "dtmf",
						"path" => $dtmfstring});

	    if ($::Loglevel >= LOG_DBUG)
	    {
		logit (LOG_DBUG, "callid=[" . $callid .
		       "] Queued DTMF-play of \"" .
		       $dtmfstring .
		       " play_queued index $index");
	    };
	}
	else
	{
	    ##  Make soundcache requests for audio plays
	    @sc_request_items = ();
	    push (@sc_request_items,
		  $request_id,
		  $sc_options,
		  $sc_cookies);
	    if (defined ($spec->{"url"}))
	    {
		push (@sc_request_items,
		      "url", clean_url_path($spec->{"url"}));
	    };
	    if (defined ($spec->{"tts"}))
	    {
		push (@sc_request_items,
		      "tts", $spec->{"tts"});
	    };
	    $sc_request = join (" ", @sc_request_items);

	    ##  put the prompt spec in the play_queued array.
	    if (! defined ($fhinfo->{"play_queued"}))
	    {
		$fhinfo->{"play_queued"} = [];
	    };
	    $index = scalar (@{$fhinfo->{"play_queued"}});
	    push (@{$fhinfo->{"play_queued"}}, {"status" => 0,
						"type" => "audio",
						"request_id" => $request_id,
						"bargein" => $bargein_value});

	    if ($::Loglevel >= LOG_DBUG)
	    {
		logit (LOG_DBUG, "callid=[" . $callid .
		       "] made sound cache request screq=[" .
		       $request_id .
		       "] for bargein=" . $bargein_value .
		       " play_queued index $index as: " .
		       $sc_request);
	    };

	    ##  Send out the sound cache request
	    send_bytes ($::SC_fhinfo, $sc_request . "\n");

	    ##  and record the request to it
	    $::SC_request_id_info->{$request_id} =
	    {"vxml_fh" => $fhinfo->{"fh"},
	     "index" => $index};
	};
    };
};

##  handle_ovxi_pcmqueue ($fh_spec, $ovximsg)
##    -- Handles "pcmqueue" message in $ovxi_msg from OVXI for VXML
##       interpreter specified by $fh_spec
sub handle_ovxi_pcmqueue
{
    my ($fhinfo) = shift (@_);
    my ($ovximsg) = shift (@_);
    my ($callid, $path, $ast_path, $bargein_spec, $bargein_value);

    $callid = $fhinfo->{"callid"};
    $path = $ovximsg->{"path"};

    ##  Parse out the bargein setting
    $bargein_spec = $ovximsg->{"bargein"};
    $bargein_value = 1;
    if ($bargein_spec eq "false") {$bargein_value = 0;};

    ##  Convert from local path to Asterisk path
    if (substr ($path, 0, length ($::VgSoundDir)) eq $::VgSoundDir)
    {
	substr ($path, 0, length ($::VgSoundDir)) = $::AstSoundPrefix;
    }
    else
    {
	if ($::Loglevel >= LOG_EROR)
	{
	    logit (LOG_EROR, "callid=[" . $callid .
		   "] invalid PCMQueue path \"" .
		   $path .
		   "\", doesn't start with \"" .
		   $::VgSoundDir . "\"");
	};
	return;
    };

    ##  put the promptspec in the play_queued array.
    if (! defined ($fhinfo->{"play_queued"}))
    {
	$fhinfo->{"play_queued"} = [];
    };
    push (@{$fhinfo->{"play_queued"}}, {"status" => 1,
					"type" => "audio",
					"bargein" => $bargein_value,
					"path" => $path});
    if ($::Loglevel >= LOG_DBUG)
    {
	logit (LOG_DBUG, "callid=[" . $callid .
	       "] queued bargein=" . $bargein_value . " PCM prompt " . $path);
    };
};

##  handle_ovxi_recognize ($fh_spec, $ovximsg)
##    -- Handles "recognize" message in $ovxi_msg from OVXI for VXML
##       interpreter specified by $fh_spec
sub handle_ovxi_recognize
{
    my ($fhinfo) = shift (@_);
    my ($ovximsg) = shift (@_);
    my ($callid);

    $callid = $fhinfo->{"callid"};
    if (! defined ($fhinfo->{"connected"}))
    {
	send_vxml_interp_msg ($fhinfo, "Recognized 0 " . NLSML_NOINPUT);
	return;
    };

    ##  Extract recognition parameters
    defined ($fhinfo->{"rec_timeout"} =
	     parse_vxml_timeval ($ovximsg->{"properties"}{"timeout"}))
      || ($fhinfo->{"rec_timeout"} = 7000);
    defined ($fhinfo->{"interdigittimeout"} =
	     parse_vxml_timeval($ovximsg->{"properties"}{"interdigittimeout"}))
      || ($fhinfo->{"interdigittimeout"} = 7000);
    defined ($fhinfo->{"termtimeout"} =
	     parse_vxml_timeval($ovximsg->{"properties"}{"termtimeout"}))
      || ($fhinfo->{"termtimeout"} = 0);
    defined ($fhinfo->{"termchar"} = $ovximsg->{"properties"}{"termchar"})
      || ($fhinfo->{"termchar"} = "");

    ($::Loglevel >= LOG_DBUG)
      && logit (LOG_DBUG, "callid=[" . $callid .
		"] doing recognition with timeout=" .
		$fhinfo->{"rec_timeout"});

    $fhinfo->{"play_requested"} = 1;
    $fhinfo->{"recognize_requested"} = 1;
    $fhinfo->{"vxml_doing"} = $ovximsg->{"msgtype"};
    do_prompt_and_listen ($fhinfo);
};

##  handle_ovxi_transfer ($fh_spec, $ovximsg)
##    -- Handles "Transfer" message in $ovxi_msg from OVXI for VXML
##       interpreter specified by $fh_spec
sub handle_ovxi_transfer
{
    my ($fhinfo) = shift (@_);
    my ($ovximsg) = shift (@_);
    my ($callid, $url, $satc_command);

    $callid = $fhinfo->{"callid"};
    if (! defined ($fhinfo->{"connected"}))
    {
	send_vxml_interp_msg ($fhinfo, "Transfered");
	return;
    };

    ($::Loglevel >= LOG_DBUG)
      && logit (LOG_DBUG, "callid=[" . $callid .
		"] starting transfer to url=" .
		$ovximsg->{"url"});

    ##  Generate the transfer command
    $url = $ovximsg->{"url"};
    # Don't massage the url here is it breaks non-SIP transfers
    # if ($url =~ /^sip:/i)
    # {
	# $url =~ s/^sip:/sip\//i;
    # }
    # else
    # {
	# $url = "sip/" . $url;
    # };
    $satc_command = {Satc::MSGTYPE => Satc::TRANSFER,
		     Satc::CALLID => $callid,
		     Satc::URL => $url,
		     Satc::FLAG =>
		     (($::Blind_transfer_method eq "dial") ? 1 : 0)};

    ##  Update vxml_doing
    $fhinfo->{"vxml_doing"} = $ovximsg->{"msgtype"};

    ##  Start the transfer
    send_ct_client_msg ($::CTSrvInfo, $satc_command);
};

##  handle_ovxi_record ($fh_spec, $ovximsg)
##    -- Handles "Record" message in $ovxi_msg from OVXI for VXML
##       interpreter specified by $fh_spec
sub handle_ovxi_record
{
    my ($fhinfo) = shift (@_);
    my ($ovximsg) = shift (@_);
    my ($ok, $msg, $callid);

    $callid = $fhinfo->{"callid"};
    if (! defined ($fhinfo->{"connected"}))
    {
	send_vxml_interp_msg ($fhinfo, "Recorded " . VXIrec_RESULT_FAILURE);
	return;
    };

    defined ($fhinfo->{"record_tone"} =
	     parse_vxml_bool ($ovximsg->{"properties"}{"beep"}))
      || ($fhinfo->{"record_tone"} = 1);
    defined ($fhinfo->{"rec_maxtime"} =
	     parse_vxml_timeval ($ovximsg->{"properties"}{"maxtime"}))
      || ($fhinfo->{"rec_maxtime"} = 600000);
    defined ($fhinfo->{"rec_finalsilence"} =
	     parse_vxml_timeval ($ovximsg->{"properties"}{"finalsilence"}))
      || ($fhinfo->{"rec_finalsilence"} = 5000);
    defined ($fhinfo->{"rec_type"} = $ovximsg->{"properties"}{"rectype"})
      && length ($fhinfo->{"rec_type"})
	|| ($fhinfo->{"rec_type"} = "audio/basic");
    defined ($fhinfo->{"rec_dtmfterm"} =
	     parse_vxml_bool ($ovximsg->{"properties"}{"dtmfterm"}))
      || ($fhinfo->{"rec_dtmfterm"} = 1);
    $fhinfo->{"play_requested"} = 1;
    $fhinfo->{"record_requested"} = 1;
    $fhinfo->{"vxml_doing"} = $ovximsg->{"msgtype"};
    do_prompt_and_listen ($fhinfo);
};

##  handle_ovxi_grammar_status ($fh_spec, $ovximsg)
##    -- Handles grammar activation and deactivation messages
##       in $ovxi_msg from OVXI for VXML
##       interpreter specified by $fh_spec
sub handle_ovxi_grammar_status
{
    my ($fhinfo) = shift (@_);
    my ($ovximsg) = shift (@_);
    my ($active_status) = shift (@_);
    my ($callid) = $fhinfo->{"callid"};
    my ($gram_id) = $ovximsg->{"gram_id"};
    my ($msgtype) = $ovximsg->{"msgtype"};

    ##  Check that the gram_id has been loaded
    if (! defined $fhinfo->{"gram_ids"}{$gram_id})
    {
	##  Activation/Deactivation failure
	($::Loglevel >= LOG_EROR)
	  && logit (LOG_EROR, "callid=[" . $callid .
		    "] cannot " . $::OVXITypeToOVXIMsg->{$msgtype} .
		    ", unrecognized grammar id " .
		    $gram_id);
	send_vxml_interp_msg ($fhinfo, "1");
	return;
    };

    ##  Activation/Deactivation success
    $fhinfo->{"gram_ids"}{$gram_id}{"active"} =
      (($msgtype == OVXI_ACTIVATEGRAMMAR) ? 1 : 0);
    delete $fhinfo->{"gram_signals"};
    ($::Loglevel >= LOG_DBUG)
      && logit (LOG_DBUG, "callid=[" . $callid .
		"] " . $::OVXITypeToOVXIMsg->{$msgtype} . " " .
		$ovximsg->{"gram_id"} . " done");
    send_vxml_interp_msg ($fhinfo, "0");
};

##  handle_ovxi_grammar ($fh_spec, $ovximsg)
##    -- Handles "Grammar" message in $ovxi_msg from OVXI for VXML
##       interpreter specified by $fh_spec
sub handle_ovxi_grammar
{
    my ($fhinfo) = shift (@_);
    my ($ovximsg) = shift (@_);
    my ($ok, $msg, $rule, $modes, $builtin_grammar, $xlation);
    my ($callid) = $fhinfo->{"callid"};
    my ($grammar_text) = $ovximsg->{"grammar"};
    my ($gram_id) = $ovximsg->{"gram_id"};
    my ($gram_type) = $ovximsg->{"gram_type"};

    ##  Check for mode and type
    if (($gram_type ne "text/x-grammar-choice-dtmf") &&
	($gram_type ne "application/srgs+xml"))
    {
	if ($grammar_text =~ /^builtin:[^\/]+\/(.*)$/)
	{
	    ##  Found a builtin grammar request, try to translate it
	    $builtin_grammar = $1;
	    ($::Loglevel >= LOG_DBUG)
	      && logit (LOG_DBUG, "callid=[" . $callid .
			"] detected builtin grammar, translating");
	    ($ok, $msg, $xlation) = translate_builtin ($builtin_grammar);
	    if (! $ok)
	    {
		($::Loglevel >= LOG_EROR)
		  && logit (LOG_EROR, "callid=[" . $callid .
			    "] invalid builtin grammar \"" .
			    $builtin_grammar . "\": " . $msg);
		send_vxml_interp_msg ($fhinfo, "Grammar 1");
		return;
	    };
	    $grammar_text = $xlation;
	}
	elsif ($gram_type eq "text/x-grammar-choice")
	{
	    ##  OVXI shouldn't be passing these to me, so just
	    ##  create a never-matching grammar.
	    $grammar_text = "<rule id=\"nomatch\" scope=\"public\">
  <item> Z </item>
</rule>
";
	}
	else
	{
	    ($::Loglevel >= LOG_EROR)
	      && logit (LOG_EROR, "callid=[" . $callid .
			"] invalid grammar type \"" .
			$gram_type . "\"");
	    send_vxml_interp_msg ($fhinfo, "Grammar 1");
	    return;
	};
    };
    if ((! defined ($modes = $ovximsg->{"properties"}{"inputmodes"})) ||
	($modes ne "dtmf"))
    {
	($::Loglevel >= LOG_EROR)
	  && logit (LOG_EROR, "callid=[" . $callid .
		    "] invalid inputmodes \"" .
		    $modes . "\", must be dtmf");
	send_vxml_interp_msg ($fhinfo, "Grammar 1");
	return;
    };

    ##  Convert choice grammars to SRGS grammars
    if ($grammar_text =~ /^[ 0123456789\*\#]$/)
    {
	($ok, $msg, $xlation) = translate_choice ($grammar_text);
	if (! $ok)
	{
	    ($::Loglevel >= LOG_EROR)
	      && logit (LOG_EROR, "callid=[" . $callid .
			"] invalid choice grammar \"" .
			$grammar_text . "\": " . $msg);
	    send_vxml_interp_msg ($fhinfo, "Grammar 1");
	    return;
	};
	$grammar_text = $xlation;
    };

    ##  Parse this grammar if it hasn't already been parsed
    if (! defined ($rule = $::Gram_text_to_rule->{$grammar_text}))
    {
	($ok, $msg, $rule) = SRGSDTMF::parse_srgsdtmf_grammar ($grammar_text);
	if (! $ok)
	{
	    ##  Parse failure
	    ($::Loglevel >= LOG_EROR)
	      && logit (LOG_EROR, "callid=[" . $callid .
			"] Unparseable grammar id " .
			$gram_id . " : " . $msg .
			" for " . $grammar_text);
	    send_vxml_interp_msg ($fhinfo, "Grammar 1");
	    return;
	};

	##  Parse success
	$::Gram_text_to_rule->{$grammar_text} = $rule;
	$rule->{"text"} = $grammar_text;
	if ($::Loglevel >= LOG_DBUG)
	{
	    logit (LOG_DBUG, "callid=[" . $callid . "] New grammar id " .
		   $gram_id . " parsed");
	};
    }
    else
    {
	if ($::Loglevel >= LOG_DBUG)
	{
	    logit (LOG_DBUG, "callid=[" . $callid . "] New grammar id " .
		   $gram_id . " assigned to previous parse");
	};
    };
    $fhinfo->{"gram_ids"}{$gram_id} = {"active" => 0,   ##  start out inactive
				       "rule" => $rule};
    $fhinfo->{"gram_texts"}{$grammar_text}{$gram_id} = 1;
    send_vxml_interp_msg ($fhinfo, "Grammar 0");
};

##  handle_ovxi_getpcmpath ($fh_spec, $ovximsg)
##    -- Handles "GetPCMPath" message in $ovxi_msg from OVXI for VXML
##       interpreter specified by $fh_spec
sub handle_ovxi_getpcmpath
{
    my ($fhinfo) = shift (@_);
    my ($ovximsg) = shift (@_);
    my ($callid) = $fhinfo->{"callid"};
    my ($numeric_id, $path, $extension);

    if ($ovximsg->{"pcm_id"} =~ /^x-vxiprompt-ref_internalName_(\d+)$/)
    {
	$numeric_id = $1;
    };

    if (! defined ($numeric_id))
    {
	($::Loglevel >= LOG_WARN)
	  && logit (LOG_WARN, "callid=[" . $callid .
		    "] invalid format of PCM id \"" .
		    $ovximsg->{"pcm_id"});
	$numeric_id = $ovximsg->{"pcm_id"};
    };
    $extension = (($ovximsg->{"pcm_type"} =~ /alaw/) ? "alaw" : "ulaw");
    $path = join ("/", $::VgSoundDir, "rec",
		  join ("_", $$, $callid, "prompt", $numeric_id)) .
		    "." . $extension;

    send_vxml_interp_msg ($fhinfo, join (" ", "PCMPath", $path));
};

##  handle_ovxi_exitval ($fh_spec, $ovximsg)
##    -- Handles "exitval" message in $ovxi_msg from OVXI for VXML
##       interpreter specified by $fh_spec
sub handle_ovxi_exitval
{
    my ($fhinfo) = shift (@_);
    my ($ovximsg) = shift (@_);
    my ($callid) = $fhinfo->{"callid"};
    my ($spec) = $ovximsg->{"varspec"};
    my ($var, $value, $satc_command);

    if ($spec =~ /^([^=]+)=(.*)$/)
    {
	$var = $1;
	$value = $2;
    }
    else
    {
	($::Loglevel >= LOG_EROR)
	  && logit (LOG_EROR, "callid=[" . $callid .
		    "] invalid format of exitval varspec " . $spec);
	return;
    };

    $satc_command = {Satc::MSGTYPE => Satc::RETURNVAR,
		     Satc::CALLID => $callid,
		     Satc::VAR => $var,
		     Satc::VALUE => $value};

    ##  Update vxml_doing
    $fhinfo->{"vxml_doing"} = $ovximsg->{"msgtype"};

    ##  Start the transfer
    send_ct_client_msg ($::CTSrvInfo, $satc_command);
};

##  handle_vxilog_message ($message)
##    -- Forwards log messages from VXI to generic log facility
$::Last_VXI_log_level = LOG_DBUG;
sub handle_vxilog_message
{
    my ($log_message) = shift (@_);
    my ($level);

    length ($log_message) || return;
    $level = ord ($log_message);
    if (($level < LOG_EMRG) || ($level > LOG_DBUG))
    {
	##  Did not get a valid message level
	$level = $::Last_VXI_log_level;
    }
    else
    {
	##  Did get a valid message level
	$::Last_VXI_log_level = $level;
	substr ($log_message, 0, 1, "");
    };

    ##  Forward the log message
    logit ($level, $log_message, $::Dynlog_VXImodule);
};

##  handle_soundcache_message ($message)
##    -- Receives messages from the sound cache
sub handle_soundcache_message
{
    my ($sc_message) = shift (@_);
    my ($request_id, $status, $audio_path, $req_spec, $vxml_fh);
    my ($fhinfo, $queue_index, $queue, $id, $queue_item);

    chomp ($sc_message);
    if ($::Loglevel >= LOG_DBUG)
    {
	logit (LOG_DBUG, "rcv sc: " . dump_bytes ($sc_message));
    };

    ##  Parse the message
    if ($sc_message =~ /^(\d+)\s+(\S+)\s+(.*)$/s)
    {
	$request_id = $1;
	$status = $2;
	$audio_path = $3;
    }
    else
    {
	($::Loglevel >= LOG_EROR)
	  && logit (LOG_EROR, "Unparseable msg from soundcache: " .
		    dump_bytes ($sc_message));
	return;
    };

    ##  Find this request
    if (! defined ($req_spec = $::SC_request_id_info->{$request_id}))
    {
	($::Loglevel >= LOG_EROR)
	  && logit (LOG_EROR, "Unrecognized sound cache request id " .
		    $request_id . " in " .
		    dump_bytes ($sc_message));
	return;
    };

    ##  See if the requesting thread still exists
    $vxml_fh = $req_spec->{"vxml_fh"};
    if (! defined ($fhinfo = $::Clients->{$vxml_fh}))
    {
	($::Loglevel >= LOG_DBUG)
	  && logit (LOG_DBUG, "screq=[" . $request_id .
		    "] lost its VXML thread, ignoring");
	return;
    };

    ##  See if the reuqesting thread still needs the audio item
    $queue_index = $req_spec->{"index"};
    if ((! defined ($queue = $fhinfo->{"play_queued"})) ||
	(scalar (@$queue) <= $queue_index) ||
	(! defined ($queue_item = $queue->[$queue_index])) ||
	(! defined ($id = $queue_item->{"request_id"})) ||
	($id != $request_id))
    {
	($::Loglevel >= LOG_DBUG)
	  && logit (LOG_DBUG, "screq=[" . $request_id .
		    "] no longer in play queue, ignoring");
	return;
    };

    if ($queue_item->{"status"} != 0)
    {
	($::Loglevel >= LOG_WARN)
	  && logit (LOG_WARN, "screq=[" . $request_id .
		    "] queue item already has status=" .
		    $queue_item->{"status"} . ", ignoring");
	return;
    };

    ##  Update the item
    $queue_item->{"status"} = $status;
    $queue_item->{"path"} = $audio_path;
    delete $queue_item->{"request_id"};

    ##  See if plays now need to start
    do_prompt_and_listen ($fhinfo);
};

##  handle_msg_from_vxml_interp ($fh_spec, $bytes)
##    -- Handles incoming message in $bytes from a VXML interpreter
##       on filehandle with $::Clients entry $fh_spec
sub handle_msg_from_vxml_interp
{
    my ($fhinfo) = shift (@_);
    my ($bytes) = shift (@_);
    my ($ovximsg, $callid, $msgtype);
    my ($ok, $msg, $errmsg);

    $callid = $fhinfo->{"callid"};

    if (! $fhinfo->{"processing"})
    {
	$fhinfo->{"processing"} = 1;
    };

    if ($::Loglevel >= LOG_DBUG)
    {
	logit (LOG_DBUG, "callid=[" . $callid .
	       "] rcv ovxi: " . dump_bytes ($bytes));
    };

    chop ($bytes);
    (substr ($bytes, -1) eq "\r") && chop ($bytes);

    ##  First, see if it is the empty message signifying end-of-thread
    if (! length ($bytes))
    {
	##  Handle end-of-VXML-thread signal
	($::Loglevel >= LOG_NOTI)
	  && logit (LOG_NOTI, "callid=[" . $callid .
		    "] VXML interpreter thread exited" .
		    " =#[#= " . sprintf ("%.3f", systime()) .
		    " call end " . $callid . " =#]#=");

	##  Must clean up the VXML thread
	if ((! $ok)  && ($::Loglevel >= LOG_DBUG))
	{
	    logit (LOG_DBUG, "callid=[" . $callid .
		   "] deallocating VXML thread");
	};
	($ok, $msg) = Vxglue::_stop_voiceglue_thread ($fhinfo->{"call_handle"});
	if ((! $ok)  && ($::Loglevel >= LOG_EROR))
	{
	    logit (LOG_EROR, "callid=[" . $callid .
		   "] got failure from _stop_voiceglue_thread");
	};
	--$::VXML_threads;

	if (defined ($callid) && defined ($fhinfo->{"connected"}))
	{
	    ##  Must release the call
	    ($::Loglevel >= LOG_NOTI)
	      && logit (LOG_NOTI, "callid=[" . $callid .
			"] releasing call because VXML interpreter exited");
	    send_ct_client_msg
	      ($::CTSrvInfo, {Satc::MSGTYPE => Satc::RELEASE,
			      Satc::CALLID => $callid});
	    delete $fhinfo->{"connected"};
	};

	##  Close both of the filehandles associated with the VXML thread
	POSIX::close ($fhinfo->{"vxml_fd"});
	delete $::Callid_to_vxml_fh->{$callid};
	remove_client ($fhinfo->{"fh"});
	$::Scom->unregister ($fhinfo->{"fh"});
	return;
    };

    ##  First, parse it into its fields
    if (! (($ok, $errmsg, $ovximsg) = parse_ovxi_msg ($fhinfo, $bytes))[0])
    {
	($::Loglevel >= LOG_EROR)
	  && logit (LOG_EROR, $errmsg . " from " .
		    describe_fh ($fhinfo->{"fh"}) . " in msg " .
		    dump_bytes ($bytes));
	return;
    };

    $msgtype = $ovximsg->{"msgtype"};
    if ($msgtype == OVXI_STARTED)
    {
	##  Just for debug for now
	($::Loglevel >= LOG_DBUG)
	  && logit (LOG_DBUG, "callid=[" . $callid .
		    "] got msg: " .
		    describe_ovxi_msg ($ovximsg) .
		    " from " .
		    describe_fh ($fhinfo->{"fh"}));

	send_vxml_interp_msg ($fhinfo, "continue");
    }
    elsif (($msgtype == OVXI_ACTIVATEGRAMMAR) ||
	   ($msgtype == OVXI_DEACTIVATEGRAMMAR))
    {
	handle_ovxi_grammar_status ($fhinfo, $ovximsg);
    }
    elsif ($msgtype == OVXI_RECOGNIZE)
    {
	handle_ovxi_recognize ($fhinfo, $ovximsg);
    }
    elsif ($msgtype == OVXI_QUEUE)
    {
	handle_ovxi_queue ($fhinfo, $ovximsg);
    }
    elsif ($msgtype == OVXI_PLAY)
    {
	handle_ovxi_play ($fhinfo, $ovximsg);
    }
    elsif ($msgtype == OVXI_WAIT)
    {
	handle_ovxi_wait ($fhinfo, $ovximsg);
    }
    elsif ($msgtype == OVXI_BUILTIN)
    {
	handle_ovxi_builtin ($fhinfo, $ovximsg);
    }
    elsif ($msgtype == OVXI_GETLINESTATUS)
    {
	handle_ovxi_getlinestatus ($fhinfo, $ovximsg);
    }
    elsif ($msgtype == OVXI_DISCONNECT)
    {
	handle_ovxi_disconnect ($fhinfo, $ovximsg);
    }
    elsif ($msgtype == OVXI_TRANSFER)
    {
	handle_ovxi_transfer ($fhinfo, $ovximsg);
    }
    elsif ($msgtype == OVXI_RECORD)
    {
	handle_ovxi_record ($fhinfo, $ovximsg);
    }
    elsif ($msgtype == OVXI_GRAMMAR)
    {
	handle_ovxi_grammar ($fhinfo, $ovximsg);
    }
    elsif ($msgtype == OVXI_GETPCMPATH)
    {
	handle_ovxi_getpcmpath ($fhinfo, $ovximsg);
    }
    elsif ($msgtype == OVXI_PCMQUEUE)
    {
	handle_ovxi_pcmqueue ($fhinfo, $ovximsg);
    }
    elsif ($msgtype == OVXI_EXITVAL)
    {
	handle_ovxi_exitval ($fhinfo, $ovximsg);
    }
    else
    {
	($::Loglevel >= LOG_EROR)
	  && logit (LOG_EROR, "Unsupported msg " .
		    describe_ovxi_msg ($ovximsg) .
		    " from " .
		    describe_fh ($fhinfo->{"fh"}));
    };
};

##  handle_command_message ($fh, $bytes)
##    -- Handles message from command filehandle $fh in $bytes
sub handle_command_message
{
    my ($fh) = shift;
    my ($bytes) = shift;
    my ($ok, $msg, $stopin_bytes);

    chomp ($bytes);
    if (($bytes eq "stop") ||
	($bytes eq "exit") ||
	($bytes eq "quit"))
    {
	if ($::Loglevel >= LOG_DBUG)
	{
	    logit (LOG_DBUG, "Starting controlled voiceglue shutdown " .
		   "on request from user command: " . $bytes);
	};

	##  Stop voiceglue processing when all current calls are done
	(($ok, $msg, $stopin_bytes) =
	 $::Satc->encode ({Satc::MSGTYPE => Satc::STOPIN}))[0]
	   || logit (LOG_EROR, "Satc encode failure on Satc::STOPIN: $msg");
	($ok, $msg) = $::Scom->write ($::CTSrvFh, $stopin_bytes);
	if (! $ok)
	{
	    fh_stopped ($::CTSrvFh, $msg);
	};
	$::Stop_requested = 1;
	($::VXML_threads == 0) && ($::Finished = 1);
	($ok, $msg) = $::Scom->write ($fh, "Stopping voiceglue, currently " .
				      $::VXML_threads .
				      " VXML threads running\n");
	if (! $ok)
	{
	    fh_stopped ($fh, $msg);
	};
    }
    else
    {
	($ok, $msg) = $::Scom->write ($fh, "Unrecognized command: $bytes\n");
	if (! $ok)
	{
	    fh_stopped ($fh, $msg);
	};
    };
};


##  ($ok, $msg, $param_map) = parse_configfile();
##    -- Checks if the URL file needs to be re-read,
##       and does so if it needs it.
##       Returns $ok of 1 on no-need-to-re-read, 2 on re-read, 0 on failure.
##       $param_map is the map of parameters found in the file.
sub parse_configfile
{
    my ($ok, $msg, $mtime, $conf_map, @statresult);
    my ($param_map) = {};

    ##  Check if the $::Conffile has been modified
    defined ($::Conffile) || return (1, "", $param_map);
    scalar (@statresult = stat ($::Conffile))
      || return (0, "Cannot stat \"$::Conffile\": $!", $param_map);
    defined ($::Conffile_last_mtime) || ($::Conffile_last_mtime = 0);
    (($mtime = $statresult[9]) == $::Conffile_last_mtime)
      && return (1, "", $param_map);

    ##  $::Conffile has been modified, and must be re-parsed
    $::Conffile_last_mtime = $mtime;
    ($ok, $msg, $conf_map) =
      Voiceglue::Conf::parse_voiceglue_conf ($::Conffile);
    if (! $ok)
    {
	($::Loglevel >= LOG_WARN)
	  && logit (LOG_WARN, "Errors when parsing " . $::Conffile .
		    " : " . $msg);
    };
    $::URLmap = $conf_map->{"urls"};
    $param_map = $conf_map->{"params"};

    return (2, "", $param_map);
};

##  The size of the current file
$::Current_log_file_size = 0;

##  $bytes = get_next_bytes ($filehandle)
##    Returns next bytes received from $filehandle, or undef on close
sub get_next_bytes
{
    my ($filehandle) = shift (@_);
    my ($datum, $bytes, $datumlist, @events);
    my Cam::Scom::Event $event;
    @events = $::Scom->getevents (-1, $filehandle);
    while (defined ($datumlist = shift (@events)))
    {
	shift (@$datumlist);
	while (defined ($datum = shift (@$datumlist)))
	{
	    if (ref ($datum))
	    {
		return undef;
	    }
	    else
	    {
		$bytes .= $datum;
	    };
	};
    };
    return $bytes;
};

##  initialize_log()
##    -- Initializes logging.  If $::Loghost is defined, tries to
##       use it as a dynlog host.
sub initialize_log
{
    openlogfile (1);
    (defined ($::Loghost)) && opendynlog();
    $::Logging_enabled = 1;
    log_new_day();
};

##  shutdown_log()
##    -- Shuts down logging.
sub shutdown_log
{
    my ($ok, $msg);

    if (! $::Time_of_next_connect_to_log_server)
    {
	logtofile (LOG_INFO, "disconnecting from dynlog server",
		   $::Dynlog_Mymodule, $::Dynlog_Mythread);
	($ok, $msg) = $::Scom->unregister ($::Log_fh);
	if (! $ok)
	{
	    logtofile (LOG_INFO,
		       "cannot disconnect from dynlog server : $msg",
		       $::Dynlog_Mymodule, $::Dynlog_Mythread);
	};
	$::Time_of_next_connect_to_log_server = 1;
    }
};

##  $hash = eight_byte_simplehash ($string)
##    -- Returns a 16-character hex hash of $string
sub eight_byte_simplehash
{
    my ($item) = shift (@_);
    my ($hash_bucket, $char_num);
    my (@hashnums) = (0, 0, 0, 0, 0, 0, 0, 0);
    my (@path_chars) = split (//, $item);
    for ($char_num = 0; $char_num < scalar(@path_chars); ++$char_num)
    {
	$hash_bucket = $char_num % 8;
	$hashnums[$hash_bucket] += ord($path_chars[$char_num]);
    };
    return join ("", map (sprintf ("%02X", ($_ % 256)),  @hashnums));
};

##  $escaped_cookie = escape_cookie ($cookie)
##    -- Returns $cookie escaped using cookie escaping rules,
##       which includes eliminating "=", "#", and ":".
sub escape_cookie
{
    my ($cookie) = shift (@_);
    $cookie =~ s/%/%25/gs;
    $cookie =~ s/\//%2F/gs;
    $cookie =~ s/=/%3D/gs;
    $cookie =~ s/#/%23/gs;
    $cookie =~ s/:/%3A/gs;
    $cookie =~ s/ /%20/gs;
    $cookie =~ s/\t/%09/gs;
    $cookie =~ s/\r/%0D/gs;
    $cookie =~ s/\n/%0A/gs;
    return $cookie;
};

##  $cookie = unescape_cookie ($escaped_cookie)
##    -- Returns $cookie unescaped using cookie escaping rules
sub unescape_cookie
{
    my ($cookie) = shift (@_);
    $cookie =~ s/%0A/\n/igs;
    $cookie =~ s/%0D/\r/igs;
    $cookie =~ s/%09/\t/gs;
    $cookie =~ s/%20/ /gs;
    $cookie =~ s/%3A/:/igs;
    $cookie =~ s/%23/#/igs;
    $cookie =~ s/%3D/=/igs;
    $cookie =~ s/%2F/\//igs;
    $cookie =~ s/%25/%/gs;
    return $cookie;
};

##  $hashname = sc_compute_hashname ($soundreq);
##    -- Computes, stores, and returns the hashname corresponding to $soundreq
sub sc_compute_hashname
{
    my ($soundreq) = shift (@_);
    my ($item, @path_components);
    my ($hashname, $orig_hash, $decollision);

    if (defined ($::SC_soundreq_to_hashname->{$soundreq}))
    {
	##  hashnane already defined
	$hashname = $::SC_soundreq_to_hashname->{$soundreq};
    }
    else
    {
	##  Must compute new hashname
	$item = $soundreq;
	if (scalar (@path_components = split ("/", $soundreq)) > 1)
	{
	    $item = join ("/", reverse (@path_components));
	};
	$hashname = Satc::hashify($item, 42, 2);
	$hashname =~ s/[^a-zA-Z0-9_\-]/_/gs;
	$orig_hash = $hashname;
	$decollision = 0;
	while (defined ($::SC_hashname_to_soundreq->{$hashname}))
	{
	    $hashname = $orig_hash . "_" . ++$decollision;
	};
	##  Record it
	$::SC_soundreq_to_hashname->{$soundreq} = $hashname;
	$::SC_hashname_to_soundreq->{$hashname} = $soundreq;
    };

    return $hashname;
};

##  ($ok, $msg, $soundreq, $path, $hashname, $host) =
##      sc_request_to_params ($type, $item, $cookies, $cacheable);
##    -- Given a sound cache request $type and $item and $cookies
##       (a hashref mapping names to values), returns
##       the file path for its content relative to $::VgSoundDir,
##       the hashname used for single-level access under link/. and
##       the host for the URL (or "" if it's TTS).
##       On error $ok is false, and $msg is an error message
sub sc_request_to_params
{
    my ($type) = shift (@_);
    my ($item) = shift (@_);
    my ($cookies) = shift (@_);
    my ($cacheable) = shift (@_);
    my ($soundreq, $fixed_name, @path_chars, $path, @path_components);
    my ($component, $leaf_component, $decollision, $orig_path);
    my ($hashname, $cookie_name, $cookie_value, @cookie_components);
    my ($host) = "";
    defined ($::SC_uncacheable_oneup) || ($::SC_uncacheable_oneup = 0);

    if ($type eq "tts")
    {
	$soundreq = $item;
	$cacheable || ($soundreq .= "<" . ++$::SC_uncacheable_oneup . ">");

	##  Compute hashname
	$hashname = sc_compute_hashname($soundreq);

	##  Compute path (guaranteed unique because based on hashname)
	$path = join ("/", $type, join (".", $hashname, "wav"));
    }
    elsif ($type eq "url")
    {
	##  Compute the cookie components (implicit parameters)
	@cookie_components = ();
	foreach $cookie_name (sort (keys (%$cookies)))
	{
	    push (@cookie_components,
		  join (":", escape_cookie($cookie_name),
			escape_cookie($cookies->{$cookie_name})));
	};

	##  Compute soundreq
	$soundreq = join ("/", $item, @cookie_components);
	$cacheable || ($soundreq .= "<" . ++$::SC_uncacheable_oneup . ">");

	##  Compute hashname
	$hashname = sc_compute_hashname($soundreq);

	##  See if path already computed
	if (! defined ($path = $::SC_soundreq_to_path->{$soundreq}))
	{
	    ##  Compute path from URL components
	    @path_components = split (/\//, $item);
	    if (scalar (@path_components) < 4)
	    {
		return (0, "Insufficient URL components in path for \"$item\"");
	    };
	    if (! length ($path_components[2]))
	    {
		$path_components[2] = "+";
	    };
	    splice (@path_components, 0, 2);
	    $host = $path_components[0];
	    foreach $component (@path_components)
	    {
		$component = escape_cookie ($component);
	    };

	    ##  Add cookie components and one-up
	    $leaf_component = pop(@path_components);
	    $cacheable
	      || ($leaf_component .= "<" . $::SC_uncacheable_oneup . ">");
	    push (@path_components, @cookie_components, $leaf_component);

	    ##  Hashify path components as necessary
	    foreach $component (@path_components)
	    {
		$component = Satc::hashify($component, 128, 8);
	    };
	    $path = join ("/", $type, @path_components);

	    ##  Uniqueify path
	    $orig_path = $path;
	    $decollision = 0;
	    while (defined ($::SC_path_to_soundreq->{$path}))
	    {
		$path = $orig_path . "_" . ++$decollision;
	    };

	    ##  Record path
	    $::SC_soundreq_to_path->{$soundreq} = $path;
	    $::SC_path_to_soundreq->{$path} = $soundreq;
	};
    };

    return (1, "", $soundreq, $path, $hashname, $host);
};

##  initialize_ovxi ($max_channels)
##    -- Initializes OpenVXI, aborts to fail() on error.
##       $max_channels is maximum number of concurrent calls.
sub initialize_ovxi
{
    my ($max_channels) = shift (@_);
    my ($c_fh, $c_fd, $r, $ok, $msg);

    ##  Create a new descriptor pair to communicate with the VXI log output
    $::VXILog_fh = "::PERL_VXILOG";
    $c_fh = "::C_VXILOG";
    no strict "refs";
    $r = socketpair($::VXILog_fh, $c_fh, AF_UNIX, SOCK_STREAM, PF_UNSPEC);
    use strict "refs";
    if (! $r)
    {
	($::Loglevel >= LOG_EROR)
	  && logit (LOG_EROR, "Unable to initialize VXI logging," .
		    " failure from socketpair(): $!");
	return;
    };

    ##  Close down the original c-side descriptor behind perl's back
    ##  so it doesn't interfere with multi-threaded use
    $c_fd = POSIX::dup (fileno ($c_fh));
    no strict "refs";
    close ($c_fh);
    use strict "refs";

    $::Clients->{$::VXILog_fh} = {"type" => FHINFO_TYPE_VXILOG,
				  "fh" => $::VXILog_fh,
				  "host" => "localhost"};
    ((($ok, $msg) = $::Scom->register ("$::VXILog_fh+"))[0])
      || fail ("Failure from Scom->register on $::VXILog_fh: $msg");
    if ($::Loglevel >= LOG_DBUG)
    {
	logit (LOG_DBUG, "Passing fd " . $c_fd .
	      " to VXI for logging, listening on " . fileno ($::VXILog_fh));
    };

    ##  Initialize the VXI platform
    (($ok, $msg, $::Platform_handle) =
     Vxglue::_start_voiceglue_platform ($max_channels,
					$c_fd, $::Loglevel))[0]
      || fail ("Failure from start_voiceglue_platform: $msg");
    if ($::Loglevel >= LOG_NOTI)
    {
	logit (LOG_NOTI, "VXI platform initialized")
    };

    ##  Set VXI diagnostic trace state
    if ($::Loglevel >= 7)
    {
	Vxglue::_set_voiceglue_trace (1);
    };
};

##  shutdown_ovxi
##    -- Shuts down OpenVXI.
sub shutdown_ovxi
{
    my ($ok, $msg);

    ##  Shutdown the VXI platform
    (($ok, $msg) =
     Vxglue::_stop_voiceglue_platform ($::Platform_handle))[0]
	 || logit (LOG_EROR, "Failure from stop_voiceglue_platform: $msg");
    if ($::Loglevel >= LOG_NOTI)
    {
	logit (LOG_NOTI, "VXI platform shutdown");
    };
};

##  ($cacheable, $reason) = is_cacheable ($header_values);
##    Returns $cacheable of true if the $header_values (hashref of arrayrefs)
##    specifies cacheable content.  $reason is a human-readable reason.
sub is_cacheable
{
    my ($header_values) = shift (@_);
    my ($value);

    (defined ($header_values->{"LAST-MODIFIED"}))
      || return (0, "no Last-Modified found in HTTP header");
    if (defined ($header_values->{"CACHE-CONTROL"}))
    {
	foreach $value (@{$header_values->{"CACHE-CONTROL"}})
	{
	    if ($header_values->{"CACHE-CONTROL"} =~ /no-cache/i)
	    {return (0, "found Cache-Control: no-cache in HTTP header");};
	    if ($header_values->{"CACHE-CONTROL"} =~ /max-age=0/i)
	    {return (0, "found Cache-Control: max-age=0 in HTTP header");};
	    if ($header_values->{"CACHE-CONTROL"} =~ /s-maxage=0/i)
	    {return (0, "found Cache-Control: s-maxage=0 in HTTP header");};
	};
    };
    ##  ZZZZZ  Should also have an Expires vs. Date check here

    return (1, "Last-Modified found in HTTP headers");
}

##  waitfor_soundcache_children();
##    -- Waits for soundcache children to exit
##       (Called before exiting)
sub waitfor_soundcache_children
{
    while (wait() != -1) {};
};

##  process_cache_child_result ($path);
##    -- Called when a new result is available from soundcache running
##       a job to retrieve $path.
sub process_cache_child_result
{
    my ($path) = shift (@_);
    my ($request_id, @request_ids);
    my ($path_spec) = $::Path_to_status->{$path};

    ##  Process all outstanding requests waiting on this path
    @request_ids = keys (%{$path_spec->{"ids"}});
    $path_spec->{"ids"} = {};
    foreach $request_id (@request_ids)
    {
	if ($path_spec->{"status"} == 1)
	{
	    ##  Return success
	    if ($::Loglevel >= LOG_DBUG)
	    {
		logit (LOG_DBUG, "screq=[$request_id] succeeded for $path " .
		      "returning success (=1)");
	    };
	    send_bytes ($::SC_Client_Fhinfo,
			"$request_id 1 " . $path_spec->{"ast_path"} . "\n");
	    delete $::Request_spec->{$request_id};
	}
	else
	{
	    ##  Failure, look for fallback
	    if ($::Loglevel >= LOG_DBUG)
	    {
		logit (LOG_DBUG,
		       "screq=[$request_id] failed for " .
		       $path . " looking for fallback");
	    };
	    shift (@{$::Request_spec->{$request_id}});
	    if (scalar (@{$::Request_spec->{$request_id}}) == 0)
	    {
		##  Out of fallbacks
		if ($::Loglevel >= LOG_DBUG)
		{
		    logit (LOG_DBUG,
			   "screq=[$request_id] no more fallbacks for $path " .
			   "returning failure (=-1)");
		};
		delete $::Request_spec->{$request_id};
		send_bytes ($::SC_Client_Fhinfo,
			    "$request_id -1 " . $path . "\n");
	    }
	    else
	    {
		##  Try fallback
		if ($::Loglevel >= LOG_DBUG)
		{
		    logit (LOG_DBUG,
			   "screq=[$request_id] trying fallback for $path ");
		};
		process_next_request_item ($request_id);
	    };
	};
    };
};

##  sound_cache_child_finished ($pid, $job_status);
##    --  handles finished sound cache child process
sub sound_cache_child_finished
{
    my ($pid) = shift (@_);
    my ($job_status) = shift (@_);
    my ($path_spec, $path, @statinfo);
    my ($content_path, $header_path, $cookies_rcv_path, $error_path);
    my ($cookies_snd_path, $reason);
    my ($ok, $msg, $i, $error_msg, $name, $value, $type, $content_type);
    my ($item, $basename, $exten, $ast_path, $link_path, $link_target);
    my ($header_values) = {};
    my (@headers) = ();

    $path = $::Pid_to_path->{$pid};
    delete $::Pid_to_path->{$pid};
    if (! defined ($path))
    {
	if ($::Loglevel >= LOG_EROR)
	{
	    logit (LOG_EROR, "Unknown pid=$pid harvested");
	};
	return;
    };

    $path_spec = $::Path_to_status->{$path};
    $item = $path_spec->{"item"};
    if (! defined ($path_spec))
    {
	if ($::Loglevel >= LOG_EROR)
	{
	    logit (LOG_EROR, "Unknown path $path from harvested pid=$pid");
	};
	return;
    };

    if ($::Loglevel >= LOG_DBUG)
    {
	logit (LOG_DBUG, "pid=$pid done on $path");
    };

    $type = $path_spec->{"type"};
    $basename = join ("/", $::VgSoundDir, $path);
    $path_spec->{"status"} = -1;  ##  Assume failure until success proven

    if ($type eq "url")
    {
	##  Handle url fetch results (from curl)
	$cookies_snd_path = $basename . ".cookies-snd";
	$cookies_rcv_path = $basename . ".cookies-rcv";
	$header_path = $basename . ".header";
	$content_path = $basename . ".tmp";
	$error_path = $basename . ".err";

	##  Check for error result from curl
	if ($job_status != 0)
	{
	    ##  Get error file, if any
	    ($ok, $msg, $error_msg) = getfile ($error_path);
	    if ($::Loglevel >= LOG_EROR)
	    {
		logit (LOG_EROR, "failed to retrieve URL " .
		       $item . " into " . $path .
		       (defined ($error_msg) ? " : " . $error_msg : ""));
	    };

	    ##  Call handler and exit
	    process_cache_child_result ($path);
	    unlink ($cookies_snd_path, $cookies_rcv_path,
		    $header_path, $content_path, $error_path);
	    return;
	};

	##  Extract headers
	if (! (($ok, $msg, @headers) = getfile_lines ($header_path))[0])
	{
	    if ($::Loglevel >= LOG_EROR)
	    {
		logit (LOG_EROR, "failed to retrieve URL $item into $path : " .
		       "no HTTP headers returned in $header_path");
	    };

	    ##  Call handler and exit
	    process_cache_child_result ($path);
	    unlink ($cookies_snd_path, $cookies_rcv_path,
		    $header_path, $content_path, $error_path);
	    return;
	};

	foreach $value (@headers)
	{
	    $value =~ s/[\r\n]//g;
	};
	logit (LOG_DBUG,"retrieval of URL $item into $path returned " .
	       "the following HTTP headers: " .
	       join ("; ", @headers));

	##  Calculate headers
	for ($i = 1; $i < scalar (@headers); ++$i)
	{
	    if ($headers[$i] =~ /^\s*([^:]+)\s*:\s*(.*)\s*$/)
	    {
		$name = $1;
		$value = $2;
		$name = uc $name;
		if (! defined ($header_values->{$name}))
		{
		    $header_values->{$name} = [$value];
		}
		else
		{
		    push (@{$header_values->{$name}}, $value);
		};
	    };
	};

	##  Set $exten to valid asterisk audio file extension based
	##  on Content-Type (hopefully)
	if ((! defined ($content_type = $header_values->{"CONTENT-TYPE"}[0])) ||
	    (! length ($content_type = lc($content_type))) ||
	    ($content_type =~ /^text\/plain/i))
	{
	    my ($assumed_type);

	    if ($::Loglevel >= LOG_DBUG)
	    {
		logit (LOG_DBUG,
		       "Trying to use file extension for $item in $path");
	    };

	    ##  Try to determine by URL extension
	    if ($item =~ /\.([a-zA-Z]+)(\?.+)?$/)
	    {
		$exten = lc $1;
		if ($::Loglevel >= LOG_DBUG)
		{
		    logit (LOG_DBUG,
			   "Found extension \"" . $exten .
			   "\", trying to use it for $path");
		};
		$assumed_type =
		  $::File_extention_to_content_type->{$exten};
	    };
	    if (defined ($assumed_type))
	    {
		($::Loglevel >= LOG_WARN)
		  && logit (LOG_WARN, "assuming Content-Type " . $assumed_type .
			    " for retrieved URL $item in $path, " .
			    "please fix returned Content-Type");
	    }
	    else
	    {
		if (defined ($content_type))
		{
		    ($::Loglevel >= LOG_EROR)
		      && logit (LOG_EROR, "Unsupported Content-Type of \"" .
				$content_type .
				"\" returned for $item in $path" .
			       (defined ($exten) ?
				" (extension of \"$exten\" did not help)"
				: ""));
		}
		else
		{
		    ($::Loglevel >= LOG_EROR)
		      && logit (LOG_EROR, "No Content-Type returned " .
				"for $item in $path" .
				(defined ($exten) ?
				 " (extension of \"$exten\" did not help)"
				 : ""));
		};
		##  Call handler and exit
		process_cache_child_result ($path);
		unlink ($cookies_snd_path, $cookies_rcv_path,
			$header_path, $content_path, $error_path);
		return;
	    };
	}
	elsif (! defined
	       ($exten =
		$::Content_type_to_file_extension->{$content_type}))
	{
	    ($::Loglevel >= LOG_EROR)
	      && logit (LOG_EROR, "Unsupported Content-Type of \"" .
			$content_type . "\" returned for $item in $path");
	    ##  Call handler and exit
	    process_cache_child_result ($path);
	    unlink ($cookies_snd_path, $cookies_rcv_path,
		    $header_path, $content_path, $error_path);
	    return;
	};

	##  Check for cacheable result
	($path_spec->{"cacheable"}, $reason) = is_cacheable ($header_values);
	if ($::Loglevel >= LOG_DBUG)
	{
	    logit (LOG_DBUG, "$item in $path is " .
		   ($path_spec->{"cacheable"} ? "" : "not ") .
		   "cacheable because " . $reason);
	};

	##  Check for 304 (Not Modified)
	##  First header line will look like:    HTTP/1.1 304 Not Modified
	##  and the content file will not be created.
	if ($headers[0] =~ /\s+304\s+/)
	{
	    ##  Existing cache version has been validated
	}
	else
	{
	    ##  Move contents onto new version
	    @statinfo = stat ($content_path);
	    if ((scalar (@statinfo) < 8) || ($statinfo[7] == 0))
	    {
		if ($::Loglevel >= LOG_EROR)
		{
		    logit (LOG_EROR, "$content_path file has bad stat: $!");
		};

		##  Call handler and exit
		process_cache_child_result ($path);
		unlink ($cookies_snd_path, $cookies_rcv_path,
			$header_path, $content_path, $error_path);
		return;
	    };

	    if (! rename ($content_path, $basename))
	    {
		if ($::Loglevel >= LOG_EROR)
		{
		    logit (LOG_EROR,
			   "Cannot rename $content_path -> $basename: $!");
		};

		##  Call handler and exit
		process_cache_child_result ($path);
		unlink ($cookies_snd_path, $cookies_rcv_path,
			$header_path, $content_path, $error_path);
		return;
	    };

	    ##  And make a symlink to it for asterisk's benefit
	    $ast_path = join ("/", $::AstSoundPrefix, "link",
			      $path_spec->{"hashname"});
	    $path_spec->{"ast_path"} = $ast_path;
	    $link_path = join ("/", $::VgSoundDir, "link",
			       join (".", $path_spec->{"hashname"}, $exten));
	    $link_target = join ("/", "..", $path);
	    unlink ($link_path);
	    if (! symlink ($link_target, $link_path))
	    {
		if ($::Loglevel >= LOG_EROR)
		{
		    logit (LOG_EROR,
			   "Cannot symlink $link_path -> $link_target: $!");
		};

		##  Call handler and exit
		process_cache_child_result ($path);
		unlink ($cookies_snd_path, $cookies_rcv_path,
			$header_path, $error_path);
		return;
	    };
	};

	##  Record success
	$path_spec->{"status"} = 1;
	$path_spec->{"time"} = $::Now;
	if ($::Loglevel >= LOG_DBUG)
	{
	    logit (LOG_DBUG, "$path content creation succeeded");
	};
	unlink ($cookies_snd_path, $cookies_rcv_path,
		$header_path, $error_path);
    }
    else
    {
	##  Handle TTS case

	##  Check for success based on content existence
	@statinfo = stat ($basename);
	if ((scalar (@statinfo) < 8) || ($statinfo[7] == 0))
	{
	    if ($::Loglevel >= LOG_EROR)
	    {
		logit (LOG_EROR, "TTS genration of $path failed, " .
		       "file has bad stat: $!");
	    };

	    ##  Call error handler and exit
	    process_cache_child_result ($path);
	    return;
	};

	##  Record success
	$ast_path = $path;
	$ast_path =~ s/\.[^\.]+$//;  ##  Remove filename extension
	$path_spec->{"ast_path"} = join ("/", $::AstSoundPrefix, $ast_path);
	$path_spec->{"status"} = 1;
	$path_spec->{"time"} = $::Now;
	if ($::Loglevel >= LOG_DBUG)
	{
	    logit (LOG_DBUG, "$path content creation succeeded");
	};
    };

    process_cache_child_result ($path);
};

##  check_sound_cache_children()
##    --  Looks for any finished sound cache child processes
sub check_sound_cache_children
{
    my ($pid, $job_status);

    while (($pid = waitpid (-1, WNOHANG)) > 0)
    {
	$job_status = $?;
	sound_cache_child_finished ($pid, $job_status);
    };
};

##  process_next_request_item ($request_id)
##    -- Attempts to satisfy the top request in $::Request_spec->{$request_id}
sub process_next_request_item
{
    my ($request_id) = shift (@_);
    my ($req_spec, $pid, $rec, $status, $path, $request_type, @cmd);
    my ($audio_path, $cookies_string, @cookies_descr, $cookie_name);

    $req_spec = $::Request_spec->{$request_id}[0];
    $path = $req_spec->{"path"};
    if ($::Loglevel >= LOG_DBUG)
    {
	$cookies_string = "{";
	@cookies_descr = ();
	foreach $cookie_name (keys (%{$req_spec->{"cookies"}}))
	{
	    push (@cookies_descr,
		  join ("=", escape_cookie ($cookie_name),
			escape_cookie ($req_spec->{"cookies"}{$cookie_name})));
	};
	if (scalar (@cookies_descr))
	{
	    $cookies_string .= join (",", @cookies_descr);
	};
	$cookies_string .= "}";
	logit (LOG_DBUG,
	       "screq=[$request_id] processing " . $req_spec->{"type"} .
	       " request soundreq=" . $req_spec->{"soundreq"} .
	       " path=" . $path .
	       " hashname=" . $req_spec->{"hashname"} .
	       " host=" . $req_spec->{"host"} .
	       " maxage=" . $req_spec->{"maxage"} .
	       " lang=" . $req_spec->{"lang"} .
	       " cookies=" . $req_spec->{"cookies"} .
	       " timeout=" . $req_spec->{"timeout"} .
	       " for " . $req_spec->{"item"});
    };

    ##  See if the $::Path_to_status knows about this path
    $status = undef;
    if (defined ($rec = $::Path_to_status->{$path}))
    {
	$status = $rec->{"status"};

	##  Check for retry on past failure
	if (($status == -1) &&
	    ($rec->{"time"} + $::Retry_seconds_for_audio_fetch_failures
	     < $::Now))
	{
	    ##  Ignore previous failure so it can be retried
	    delete $::Path_to_status->{$path};
	    $status = undef;
	    if ($::Loglevel >= LOG_DBUG)
	    {
		logit (LOG_DBUG,
		       "screq=[$request_id] retrying past failed attempt");
	    };
	};
    };

    ##  See if a previous request finished with success and
    ##  its cached value can be used implicitly
    if (defined ($status) && ($status == 1))
    {
	if (! $rec->{"cacheable"})
	{
	    if ($::Loglevel >= LOG_DBUG)
	    {
		logit (LOG_DBUG,
		       "screq=[$request_id] cannot used cached value, " .
		       "server said it was uncacheable.");
	    };
	    undef $status;
	    delete $::Path_to_status->{$path}
	}
	elsif ($req_spec->{"maxage"} <= $::Now - $rec->{"time"})
	{
	    if ($::Loglevel >= LOG_DBUG)
	    {
		logit (LOG_DBUG,
		       "screq=[$request_id] cannot use cached value, " .
		       "cached contents are too old (maxage=" .
		       $req_spec->{"maxage"} . ", age=" .
		       ($::Now - $rec->{"time"}) . ")");
	    };
	}
	else
	{
	    if ($::Loglevel >= LOG_DBUG)
	    {
		logit (LOG_DBUG,
		       "screq=[$request_id] using cached value " .
		       $rec->{"ast_path"} . " -> " . $path);
	    };
	    delete $::Request_spec->{$request_id};
	    $rec->{"last_used"} = $::Now;
	    send_bytes ($::SC_Client_Fhinfo,
			"$request_id $status " .
			$rec->{"ast_path"} .
			"\n");
	    return;
	};
    };

    ##  See if we can tag onto an existing job
    if (defined ($status) && ($status == 0))
    {
	##  Item is in process, so tag along
	$rec->{"ids"}{$request_id} = 1;
	if ($::Loglevel >= LOG_DBUG)
	{
	    logit (LOG_DBUG,
		   "screq=[$request_id] awaiting existing job pid=" .
		   $rec->{"pid"} . " for " . $path);
	};
	return;
    };

    ##  See if we have failed, and need to move to the next fallback
    if (defined ($status) && ($status == -1))
    {
	if ($::Loglevel >= LOG_DBUG)
	{
	    logit (LOG_DBUG,
		   "screq=[$request_id] result=$status (failed) in cache for " .
		   $path);
	};
	shift (@{$::Request_spec->{$request_id}});
	if (scalar (@{$::Request_spec->{$request_id}}) == 0)
	{
	    ##  Out of fallbacks
	    if ($::Loglevel >= LOG_DBUG)
	    {
		logit (LOG_DBUG,
		       "screq=[$request_id] no more fallbacks, " .
		       "returning failure (=-1)");
	    };
	    delete $::Request_spec->{$request_id};
	    send_bytes ($::SC_Client_Fhinfo,
			"$request_id $status " . $path . "\n");
	    return;
	};

	##  Try the next fallback
	process_next_request_item ($request_id);
	return;
    };

    ##  Have to generate a job.
    ##  If $status is defined, then this a revalidation of a cached item.
    ##  Put the command to run in @cmd
    $audio_path = join ("/", $::VgSoundDir, $path);
    $request_type = $req_spec->{"type"};
    if ($request_type eq "tts")
    {
	##  flite doesn't do exit status codes
	@cmd = ("voiceglue_tts_gen", "-t", $req_spec->{"item"}, $audio_path,
		$req_spec->{"lang"});
    }
    elsif ($request_type eq "url")
    {
	my ($name, $dir);
	my ($basename) = join ("/", $::VgSoundDir, $req_spec->{"path"});
	my ($cookies) = $req_spec->{"cookies"};
	my (@validation_headers) = ();

	##  Make sure the directory exists
	$dir = $basename;
	$dir =~ s/\/[^\/]*$//;
	eval { mkpath($dir) };
	if ($@)
	{
	    if ($::Loglevel >= LOG_EROR)
	    {
		logit (LOG_EROR,
		       "screq=[$request_id] Cannot mkpath \"" . $dir .
		       "\" for \"" . $path .
		      "\" : $@");
	    };
	    delete $::Request_spec->{$request_id};
	    send_bytes ($::SC_Client_Fhinfo,
			"$request_id -1 " .
			$path . "\n");
	    return;
	}

	##  Generate cookies file
	if (! open (::SCCOOKIESFH, ">$basename.cookies-snd"))
	{
	    if ($::Loglevel >= LOG_EROR)
	    {
		logit (LOG_EROR,
		       "screq=[$request_id] Cannot open \"" . $basename .
		       ".cookies-snd\" for writing for \"" . $path .
		      "\" : $!");
	    };
	    delete $::Request_spec->{$request_id};
	    send_bytes ($::SC_Client_Fhinfo,
			"$request_id -1 " .
			$path . "\n");
	    return;
	};
	foreach $name (keys (%$cookies))
	{
	    print ::SCCOOKIESFH
		(join ("\t",
		       $req_spec->{"host"},
		       "FALSE",
		       "/",
		       "FALSE",
		       "0",
		       $name,
		       $cookies->{$name}), "\n");
	};
	close (::SCCOOKIESFH);

	##  Determine headers for validation
	if (defined ($status))
	{
	    my ($gmtstring);
	    $gmtstring = gmtime($rec->{"time"}) . " GMT";
	    @validation_headers = ("-z", $gmtstring);
	};

	@cmd = ("curl", "-q", "--create-dirs",
		"-o", $basename . ".tmp",
		"-b", $basename . ".cookies-snd",
		"-c", $basename . ".cookies-rcv",
		"-D", $basename . ".header",
		"--stderr", $basename . ".err",
		@validation_headers,
		"-f", "-s", "-S",
		"-m", $req_spec->{"timeout"},
		$req_spec->{"item"})
    }
    else
    {
	if ($::Loglevel >= LOG_EROR)
	{
	    logit (LOG_EROR,
		   "screq=[$request_id] has illegal type \"" .
		   $request_type . "\" for base path \"" .
		   $path);
	};
	delete $::Request_spec->{$request_id};
	send_bytes ($::SC_Client_Fhinfo,
		    "$request_id -1 " .
		    $path . "\n");
	return;
    };

    ##  Run the command in the background
    $pid = fork();
    if (! defined ($pid))
    {
	##  Failure to fork
	if ($::Loglevel >= LOG_EROR)
	{
	    logit (LOG_EROR, "screq=[$request_id] Failure from fork: $!");
	};
	send_bytes ($::SC_Client_Fhinfo, "$request_id -1\n");
	return;
    };
    if ($pid == 0)
    {
	##  I am the child
	exec (@cmd);
	if ($::Loglevel >= LOG_EROR)
	{
	    print ::STDERR ("voiceglue soundcache: failure from exec of \"" .
			    join (" ", @cmd) . "\": $!\n");
	};
	exit (-1);
    };

    ##  I am the parent
    if ($::Loglevel >= LOG_DBUG)
    {
	logit (LOG_DBUG, "screq=[$request_id] started pid=$pid as " .
	       join (" ", @cmd));
    };

    $::Pid_to_path->{$pid} = $path;

    if (! defined ($status))
    {
	##  If not a revalidation, make a new $::Path_to_status entry
	$rec = {"type" => $request_type,
		"item" => $req_spec->{"item"},
		"hashname" => $req_spec->{"hashname"}};
	$::Path_to_status->{$path} = $rec;
    };
    $rec->{"status"} = 0;
    $rec->{"time"} = $::Now;
    $rec->{"last_used"} = $::Now;
    $rec->{"ids"} = {$request_id => 1};
    $rec->{"cacheable"} = 1;
};

##  handle_msg_from_voiceglue_main ($bytes)
##    -- Handles sound cache request in $bytes from voiceglue main
sub handle_msg_from_voiceglue_main
{
    my ($bytes) = shift (@_);
    my ($ok, $msg, $request_options, $timeout, $option, @options);
    my ($request_id, $request_type, $request_item, $path);
    my ($has_fallback, $fallback_type, $fallback_item, $fallback_path);
    my ($maxage, $cookies_spec, $hashname, $fallback_hashname, $cookies);
    my ($spec, $cookie_name, $cookie_value, @cookie_specs);
    my ($soundreq, $fallback_soundreq, $host, $fallback_host);
    my ($cacheable, $value, $lang);

    ##  First parsae out id, options, and cookies so we can
    ##  determine whether fallback parameters will be included.
    if ($bytes =~ /^(\d+)\s+(\S+)\s+(\S+)\s+/s)
    {
	$request_id = $1;
	$request_options = $2;
	$cookies_spec = $3;
    }
    else
    {
	if ($::Loglevel >= LOG_EROR)
	{
	    logit (LOG_EROR, "invalid request: "
		   . dump_bytes ($bytes) . ": bad basic parse");
	};
	return;
    };

    ##  Parse cookies
    $cookies = {};
    if ($cookies_spec ne "-")
    {
	@cookie_specs = split (/%%/, $cookies_spec);
	foreach $spec (@cookie_specs)
	{
	    if ($spec =~ /^([^=]+)=(.*)$/)
	    {
		$cookie_name = unescape_cookie($1);
		$cookie_value = unescape_cookie($2);
		$cookies->{$cookie_name} = $cookie_value;
	    }
	    else
	    {
		if ($::Loglevel >= LOG_EROR)
		{
		    logit (LOG_EROR, "Unparseable cookie spec \"" .
			   $spec . "\" in request " .
			   dump_bytes ($bytes));
		};
	    };
	};
    };

    ##  Get all options
    $timeout = $::Default_soundcache_fetch_timeout;
    $maxage = $::Default_soundcache_maxage;
    $has_fallback = 0;
    @options = split (/:/, $request_options);
    foreach $option (@options)
    {
	if ($option eq "f")
	{
	    $has_fallback = 1;
	}
	elsif (($option =~ /^t=(.+)$/) &&
	       defined ($value = parse_vxml_timeval($1, "s")))
	{
	    $timeout = $value / 1000;
	}
	elsif (($option =~ /^age=(.+)$/) &&
	       defined ($value = parse_vxml_timeval($1, "s")))
	{
	    $maxage = $value / 1000;
	}
	elsif ($option =~ /^lang=(.+)$/)
	{
	    $lang = $1;
	}
	elsif ($option ne "-")
	{
	    if ($::Loglevel >= LOG_EROR)
	    {
		logit (LOG_EROR, "Unrecognized option \"" .
		       $option . "\" in request " .
		       dump_bytes ($bytes));
	    };
	};
    };
    $cacheable = ($maxage != 0);

    $ok = 1;
    if ($has_fallback)
    {
	if ($bytes =~
	    /^\d+\s+\S+\s+\S+\s+(tts|url)\s+(\S+)\s+(tts|url)\s+(.*)$/s)
	{
	    $request_type = $1;
	    $request_item = $2;
	    $fallback_type = $3;
	    $fallback_item = $4;
	}
	else
	{
	    $ok = 0;
	};
    }
    else
    {
	if ($bytes =~ /^\d+\s+\S+\s+\S+\s+(tts|url)\s+(.*)$/s)
	{
	    $request_type = $1;
	    $request_item = $2;
	}
	else
	{
	    $ok = 0;
	};
    };
    if (! $ok)
    {
	if ($::Loglevel >= LOG_EROR)
	{
	    logit (LOG_EROR, "invalid request: "
		   . dump_bytes ($bytes) . ": bad full parse");
	};
	return;
    };

    ##  Compute primary path and hashname
    ($ok, $msg, $soundreq, $path, $hashname, $host) =
      sc_request_to_params ($request_type, $request_item, $cookies, $cacheable);
    if (! $ok)
    {
	if ($::Loglevel >= LOG_EROR)
	{
	    logit (LOG_EROR, "invalid primary item in "
		   . dump_bytes ($bytes) . ": $msg");
	};
	return;
    };

    ##  Compute fallback path and hashname
    if ($has_fallback)
    {
	($ok, $msg, $fallback_soundreq, $fallback_path,
	 $fallback_hashname, $fallback_host) =
	  sc_request_to_params
	    ($fallback_type, $fallback_item, $cookies, $cacheable);
	if (! $ok)
	{
	    if ($::Loglevel >= LOG_EROR)
	    {
		logit (LOG_EROR, "invalid fallback item in "
		       . dump_bytes ($bytes) . ": $msg");
	    };
	    return;
	};
    };

    ##  Construct $::Request_spec entry
    $::Request_spec->{$request_id} = [];
    push (@{$::Request_spec->{$request_id}},
	  {"item" => $request_item,
	   "soundreq" => $soundreq,
	   "path" => $path,
	   "type" => $request_type,
	   "hashname" => $hashname,
	   "host" => $host,
	   "maxage" => $maxage,
	   "lang" => $lang,
	   "cookies" => $cookies,
	   "timeout" => $timeout});
    if ($has_fallback)
    {
	push (@{$::Request_spec->{$request_id}},
	      {"item" => $fallback_item,
	       "soundreq" => $fallback_soundreq,
	       "path" => $fallback_path,
	       "type" => $fallback_type,
	       "hashname" => $fallback_hashname,
	       "host" => $host,
	       "maxage" => $maxage,
	       "lang" => $lang,
	       "cookies" => $cookies,
	       "timeout" => $timeout});
    };

    ##  Process the top item in the Request_spec
    process_next_request_item ($request_id);
};

##  run_sound_cache ($cmd_fh);
##    -- Runs the sound cache process, communicating with the
##       main voiceglue process over filehandle $cmd_fh.
sub run_sound_cache
{
    my ($cmd_fh) = shift (@_);
    my (@events, $fh_spec, $fh, $datumlist, $datum, $input);
    my ($ok, $msg, $timeout, $current_time, $bytes);
    my Cam::Scom::Event $event;

    ##  Don't let SIGPIPE kill me
    $::SIG{"PIPE"} = "IGNORE";

    ##  Create my own communication object and logging
    setpgrp();
    $::Dynlog_Mymodule = "SNDCACHE";
    $::SC_Client_fh = $cmd_fh;
    $::Clients->{$::SC_Client_fh} = {"type" => FHINFO_TYPE_SOUND_CACHE_CLIENT,
				     "fh" => $::SC_Client_fh,
				     "host" => "localhost"};
    $::SC_Client_Fhinfo = $::Clients->{$::SC_Client_fh};
    $::Scom = new Cam::Scom;
    $::Logfile .= "-soundcache";
    initialize_log();
    if ($::Loglevel >= LOG_NOTI)
    {
	logit (LOG_NOTI, "sound cache started");
    };
    ((($ok, $msg) = $::Scom->register ("$::SC_Client_fh+"))[0])
      || fail ("Failure from Scom->register on $::SC_Client_fh: $msg");

    ##  For curl's benefit, chdir to curl's drop location
    chdir ("$::VgSoundDir/url")
      || fail ("Cannot chdir to \"$::VgSoundDir/url\": $!");

    $::Path_to_status = {};
    $::Request_spec = {};
    $::Pid_to_path = {};

    ##  Process events
    while (1)
    {
	##  Start out assuming no timeout necessary
	$current_time = time;
	$timeout = -1;

	##  If log server is disconnected, set a timeout
	if (defined ($::Loghost) &&
	    $::Time_of_next_connect_to_log_server && ($timeout == -1))
	{
	    $timeout = $::Time_of_next_connect_to_log_server - $current_time;
	    ($timeout < 0) && ($timeout = 0);
	};

	##  Want to wake up once every second to check
	##  for terminated curls
	(($timeout == -1) || ($timeout > 1)) && ($timeout = 1);

	@events = $::Scom->getevents ($timeout);
	$::Now = time;

	##  Before handling requests, harvest any finished children
	check_sound_cache_children();

	while (defined ($datumlist = shift (@events)))
	{
	    $fh = shift (@$datumlist);
	    while (defined ($datum = shift (@$datumlist)))
	    {
		if ($fh eq $::Log_fh)
		{
		    ##  Got an event on the dynlog handle
		    if (ref ($datum))
		    {
			##  Dynlog disconnected
			$event = $datum;
			logtofile (LOG_INFO,
				   "dynlog server disconnected, code " .
				   $event->{term},
				   $::Dynlog_Mymodule, $::Dynlog_Mythread);
			$::Scom->unregister ($::Log_fh);
			$::Time_of_next_connect_to_log_server =
			  time +
			    $::Interval_between_log_server_connect_attempts;
		    }
		    else
		    {
			##  Dynlog message - only one I recognize is
			##  change in loglevel
			foreach $input (split (//, $datum))
			{
			    $input = ord ($input);
			    if (($input >= LOG_EMRG) && ($input <= LOG_DBUG))
			    {
				$::Loglevel = $input;
			    };
			};
		    };
		}
		elsif ($fh eq $::SC_Client_fh)
		{
		    ##  Got an event on the command handle from voiceglue main
		    if (ref ($datum))
		    {
			##  voiceglue main disconnected
			$event = $datum;
			logit (LOG_NOTI,
			       "voiceglue main disconnected, code " .
			       $event->{term});
			return 0;
		    }
		    else
		    {
			##  message from voiceglue main
			if ($::Loglevel >= LOG_DBUG)
			{
			    logit (LOG_DBUG, "rcv main: "
				   . dump_bytes ($datum));
			};

			##  Handle the message
			chomp ($datum);
			handle_msg_from_voiceglue_main ($datum);
		    };
		}
		else
		{
		    ##  WTF?  We just got a message on an unknown filehandle
		    if ($::Loglevel >= LOG_EROR)
		    {
			logit (LOG_EROR,
			       "rcv from UNKNOWN FILEHANDLE \"$fh\": \"" .
			       $datum . "\"");
		    };
		};
	    };
	};

	##  Check for day rollover
	if ((! defined ($::Last_day)) ||
	    ($::Last_day != (localtime)[7]))
	{
	    log_new_day();
	};

	$current_time = time;
	if ($::Time_of_next_connect_to_log_server &&
	    ($::Time_of_next_connect_to_log_server <= $current_time))
	{
	    ##  Time for another log server connection attempt
	    &opendynlog();
	};
    };
};

##  start_sound_cache()
##    -- Initializes Sound Cache process.
##       Dies with fail() on error.
sub start_sound_cache
{
    my ($sound_cache_fh, $r, $ok, $msg, $pid);

    ##  Create a new descriptor pair to communicate with the sound cache
    $::SC_fh = "::MAIN_TO_SC";
    $sound_cache_fh = "::SC_TO_MAIN";
    no strict "refs";
    $r = socketpair ($::SC_fh, $sound_cache_fh,
		     AF_UNIX, SOCK_STREAM, PF_UNSPEC);
    use strict "refs";
    $r || fail ("Unable to start sound cache," .
		" failure from socketpair(): $!");
    $pid = fork();
    defined ($pid)
      || fail ("Fail from fork() on starting sound cache: $!");
    if ($pid == 0)
    {
	##  I am the child
	no strict "refs";
	close ($::SC_fh);
	use strict "refs";
	run_sound_cache ($sound_cache_fh);
	exit (0);
    };
    ##  I am the parent
    no strict "refs";
    close ($sound_cache_fh);
    use strict "refs";
    $::Clients->{$::SC_fh} = {"type" => FHINFO_TYPE_SOUND_CACHE,
			      "fh" => $::SC_fh,
			      "host" => "localhost"};
    $::SC_fhinfo = $::Clients->{$::SC_fh};
    $::Scom = new Cam::Scom;
    ((($ok, $msg) = $::Scom->register ("$::SC_fh+"))[0])
      || fail ("Failure from Scom->register on $::SC_fh: $msg");
};

##  stop_sound_cache()
##    -- Stops Sound Cache process.
sub stop_sound_cache
{
    my ($ok, $msg);

    ((($ok, $msg) = $::Scom->unregister ("$::SC_fh"))[0])
      || logit (LOG_EROR, "Failure from Scom->unregister on $::SC_fh: $msg");
};

##  initialize_ctserver ()
##    -- Initializes CT Server, aborts to fail() on error.
sub initialize_ctserver
{
    my ($ok, $msg, $bytes, $satc_msg, $dnis, $load, $toself);

    $::Satc = new Satc;

    ##  Connect to the CT server
    $::CTSrvInfo = {"type" => FHINFO_TYPE_CT_SERVER,
		     "fh" => $::CTSrvFh,
		     "host" => $::CT_host};
    $::Clients->{$::CTSrvFh} = $::CTSrvInfo;
    (($ok, $msg) =
	$::Scom->connect ($::CTSrvFh, $::CT_host, $::CT_port,
			".", 0))[0]
	  || fail ("Cannot connect to CT Server at host $::CT_host: $msg");
    defined ($::VgConfig->{"toself"})
      && ($toself = $::VgConfig->{"toself"}[0]);
    defined ($toself) || ($toself = "");
    (($ok, $msg, $bytes) = $::Satc->encode
     ({Satc::MSGTYPE => Satc::START,
       Satc::TOSELF => $toself}))[0]
	   || fail ("Encode error on Satc::START: $msg");
    $::Scom->write ($::CTSrvFh, $bytes);
    defined ($bytes = get_next_bytes ($::CTSrvFh))
      || fail ("CT server disconnected in response to start");
    (($ok, $msg, $satc_msg) = $::Satc->decode ($bytes))[0]
      || fail ("Cannot parse CT server response to start \"" .
	       dump_bytes ($bytes) . "\": $msg");
    if ($satc_msg->{Satc::MSGTYPE} != Satc::STARTED)
    {
	fail ("Unrecognized SATC message received from CT server " .
	      "in response to start: " .
	      $::Satc->describe_msgtype ($satc_msg->{Satc::MSGTYPE}));
    };
    if ($satc_msg->{Satc::STATUS} != 0)
    {
	fail ("Failure from CT server in response to start: " .
	      $satc_msg->{Satc::MSG});
    };
    if ($::Loglevel >= LOG_NOTI)
    {
	logit (LOG_NOTI, "Connected to CT server at $::CT_host")
    };

    ##  Register everything with the CT server
    if (! defined ($::Reg))
    {
	##  Default, if not specified in config file, is to
	##  register for all incoming calls
	$::Reg = {"*" => 100};
    };
    foreach $dnis (keys (%{$::Reg}))
    {
	$load = $::Reg->{$dnis};
	(($ok, $msg, $bytes) = $::Satc->encode
	 ({Satc::MSGTYPE => Satc::REG,
	   Satc::URL => $dnis,
	   Satc::LOAD => $load}))[0]
	       || fail ("Satc encode error on Satc::REG: $msg");
	$::Scom->write ($::CTSrvFh, $bytes);
	defined ($bytes = get_next_bytes ($::CTSrvFh))
	  || fail ("CT server disconnected in response to reg");
	(($ok, $msg, $satc_msg) = $::Satc->decode ($bytes))[0]
	  || fail ("Cannot parse CT server response to reg \"" .
		   dump_bytes ($bytes) . "\": $msg");
	if ($satc_msg->{Satc::MSGTYPE} != Satc::REGED)
	{
	    fail ("Unrecognized SATC message received from CT server " .
		  "in response to reg: " .
		  $::Satc->describe_msgtype ($satc_msg->{Satc::MSGTYPE}));
	};
	if ($satc_msg->{Satc::STATUS} != 0)
	{
	    fail ("Failure from CT server in response to reg: " .
		  $satc_msg->{Satc::MSG});
	};
	if ($::Loglevel >= LOG_NOTI)
	{
	    logit (LOG_NOTI,
		   "Registered $dnis at load $load with CT server $::CT_host")
	};
    };

    ##  Allow incoming calls from the CT server
    (($ok, $msg, $bytes) =
     $::Satc->encode ({Satc::MSGTYPE => Satc::ALLOWIN}))[0]
       || fail ("Satc encode failure on Satc::ALLOWIN: $msg");
    $::Scom->write ($::CTSrvFh, $bytes);
    defined ($bytes = get_next_bytes ($::CTSrvFh))
      || fail ("CT server disconnected in response to allowin");
    (($ok, $msg, $satc_msg) = $::Satc->decode ($bytes))[0]
      || fail ("Cannot parse CT server response to allowin \"" .
	       dump_bytes ($bytes) . "\": $msg");
    if ($satc_msg->{Satc::MSGTYPE} != Satc::ALLOWEDIN)
    {
	fail ("Unrecognized SATC message received from CT server " .
	      "in response to allowin: " .
	      $::Satc->describe_msgtype ($satc_msg->{Satc::MSGTYPE}));
    };
    if ($satc_msg->{Satc::STATUS} != 0)
    {
	fail ("Failure from CT server in response to allowin: " .
	      $satc_msg->{Satc::MSG});
    };
    if ($::Loglevel >= LOG_NOTI)
    {
	logit (LOG_NOTI, "Allowed incoming calls from CT server at $::CT_host")
    };
};

##  shutdown_ctserver ()
##    -- Shuts down CT Server
sub shutdown_ctserver
{
    my ($ok, $msg, $bytes, $satc_msg, $dnis, $load, $toself);

    ##  Request disconnect from the CT server
    (($ok, $msg, $bytes) = $::Satc->encode
     ({Satc::MSGTYPE => Satc::STOP,
       Satc::TOSELF => $toself}))[0]
	   || fail ("Encode error on Satc::START: $msg");
    $::Scom->write ($::CTSrvFh, $bytes);
};

##  initialize_cmd_listener ()
##    -- Initializes command listener, aborts to fail() on error.
sub initialize_cmd_listener
{
    my ($ok, $msg);
    my ($listen_addr) = $::Cmd_host;
    length($listen_addr) && ($listen_addr ne "*") || ($listen_addr = undef);

    ##  Start up command port listener
    (($ok, $msg) =
     $::Scom->listen ($::CmdFh, $::Cmd_port, "::CMD", $listen_addr))[0]
       || fail ("Cannot listen for CMD connections: $msg");
    $::Clients->{$::CmdFh} = {"type" => FHINFO_TYPE_CMD_LISTENER,
			      "fh" => $::CmdFh,
			      "host" => $::Cmd_host};
    $::CmdInfo = $::Clients->{$::CmdFh};

    if ($::Loglevel >= LOG_INFO)
    {
	logit (LOG_INFO, "Listening for CMD connections at " .
	       (defined ($listen_addr) ? $listen_addr : "*") .
	       ":" . $::Cmd_port);
    };
};

##  shutdown_cmd_listener ()
##    -- Shuts down command listener.
sub shutdown_cmd_listener
{
    my ($ok, $msg);

    ##  Shut down command port listener
    (($ok, $msg) =
     $::Scom->unregister ($::CmdFh))[0]
       || logit (LOG_EROR,
		 "Cannot unregister listener for CMD connections: $msg");

    if ($::Loglevel >= LOG_INFO)
    {
	logit (LOG_INFO, "Stopped listening for CMD connections");
    };
};

##  $%param_map = build_urlmap()
##    -- Creates $::URLmap from $::URL and $::Conffile, and returns
##       $%param_map, which contains parameters from that file
sub build_urlmap
{
    my ($ok, $msg);
    my ($param_map);

    ##  Build $::URLmap
    if (defined ($::URL))
    {
	$::URLmap = {"*" => $::URL};
    }
    else
    {
	##  Parse config file for first time
	(($ok, $msg, $param_map) = parse_configfile())[0]
	  || fail ("Cannot parse config file \"$::Conffile\": $msg");
    };
    return $param_map;
};

##  read_configfile()
##    -- Called only at program startup to initially parse the config file
sub read_configfile
{
    my ($type, $cache_dir, @pwent);
    my ($param, $value, $dnis, $load);
    my ($config_params) = {
			   "ast_sound_dir" => 1,
			   "reg" => 0,
			   "toself" => 0,
			   "blind_xfer_method" => 0,
			   "audio_fetch_retry" => 0,
			   "audio_fetch_timeout" => 0,
			   "audio_maxage" => 0,
			   "cache_purge_interval" => 0,
			   "cache_lastused_purge" => 0,
			   "ssml_passthrough" => 0,
			  };

    ##  Extract and verify required parameters
    $::VgConfig = build_urlmap();
    defined ($::AstSoundDir)
      || defined ($::AstSoundDir = $::VgConfig->{"ast_sound_dir"}[0])
	|| die ("Parameter ast_sound_dir not defined in " . $::Conffile .
		" and not specified with --astsounddir command-line parameter");
    $::VgSoundDir .= join ("/", $::AstSoundDir, $::AstSoundPrefix);

    (-d $::VgSoundDir)
      || mkdir ($::VgSoundDir)
	|| usage ("Bad ast_sound_dir or --astsounddir: " .
		  $::AstSoundDir . " not present and cannot be made: $!");
    foreach $type ("tts", "url", "rec", "link")
    {
	$cache_dir = join ("/", $::VgSoundDir, "$type");
	(-e $cache_dir)
	  && (! (-d $cache_dir))
	    && system ("rm", "-r", "-f", $cache_dir);
	(-d $cache_dir)
	  || mkdir ($cache_dir)
	    || usage ("Cannot make sound cache directory \"$cache_dir\": $!");
	scalar (@pwent = stat ($cache_dir))
	  || usage ("Cannot stat sound cache directory $cache_dir: $!");
	if (($pwent[4] != $::Ast_uid) ||
	    (defined ($::Group_id) && ($pwent[5] != $::Group_id)))
	{
	    chown ($::Ast_uid,
		   (defined ($::Group_id) ? $::Group_id : $pwent[5]),
		   $cache_dir)
	      || usage ("Cannot chown sound cache directory $cache_dir: $!");
	};
	if (($pwent[2] & 0777) != 0775)
	{
	    chmod (0775, $cache_dir)
	      || usage ("Cannot chmod $cache_dir: $!");
	};
    };

    ##  Extract optional parameters
    foreach $param (keys(%$::VgConfig))
    {
	if ($param eq "blind_xfer_method")
	{
	    $value = $::VgConfig->{$param}[0];
	    if ($value eq "dial")
	    {
		$::Blind_transfer_method = "dial";
	    }
	    elsif ($value eq "transfer")
	    {
		$::Blind_transfer_method = "transfer";
	    }
	    else
	    {
		if ($::Loglevel >= LOG_EROR)
		{
		    logit (LOG_EROR, "invalid parameter value \"" .
			   $value .
			   "\" in configuration file for parameter \"" .
			   $param .
			   "\", ignoring");
		};
	    };
	}
	elsif ($param eq "audio_fetch_retry")
	{
	    $value = $::VgConfig->{$param}[0];
	    if (($value =~ /^\d+$/) && ($value > 0))
	    {
		$::Retry_seconds_for_audio_fetch_failures = $value;
	    }
	    else
	    {
		if ($::Loglevel >= LOG_EROR)
		{
		    logit (LOG_EROR, "invalid parameter value \"" .
			   $value .
			   "\" in configuration file for parameter \"" .
			   $param .
			   "\", ignoring");
		};
	    };
	}
	elsif ($param eq "audio_fetch_timeout")
	{
	    $value = $::VgConfig->{$param}[0];
	    if (($value =~ /^\d+$/) && ($value > 0))
	    {
		$::Default_soundcache_fetch_timeout = $value;
	    }
	    else
	    {
		if ($::Loglevel >= LOG_EROR)
		{
		    logit (LOG_EROR, "invalid parameter value \"" .
			   $value .
			   "\" in configuration file for parameter \"" .
			   $param .
			   "\", ignoring");
		};
	    };
	}
	elsif ($param eq "audio_maxage")
	{
	    $value = $::VgConfig->{$param}[0];
	    if ($value =~ /^\d+$/)
	    {
		$::Default_soundcache_maxage = $value;
	    }
	    else
	    {
		if ($::Loglevel >= LOG_EROR)
		{
		    logit (LOG_EROR, "invalid parameter value \"" .
			   $value .
			   "\" in configuration file for parameter \"" .
			   $param .
			   "\", ignoring");
		};
	    };
	}
	elsif ($param eq "cache_purge_interval")
	{
	    $value = $::VgConfig->{$param}[0];
	    if (($value =~ /^\d+$/) && ($value > 0))
	    {
		$::Cache_purge_interval = $value;
	    }
	    else
	    {
		if ($::Loglevel >= LOG_EROR)
		{
		    logit (LOG_EROR, "invalid parameter value \"" .
			   $value .
			   "\" in configuration file for parameter \"" .
			   $param .
			   "\", ignoring");
		};
	    };
	}
	elsif ($param eq "cache_lastused_purge")
	{
	    $value = $::VgConfig->{$param}[0];
	    if (($value =~ /^\d+$/) && ($value > 0))
	    {
		$::Cache_purge_unused_time = $value;
	    }
	    else
	    {
		if ($::Loglevel >= LOG_EROR)
		{
		    logit (LOG_EROR, "invalid parameter value \"" .
			   $value .
			   "\" in configuration file for parameter \"" .
			   $param .
			   "\", ignoring");
		};
	    };
	}
	elsif ($param eq "reg")
	{
	    foreach $value (@{$::VgConfig->{$param}})
	    {
		if ($value =~ /^(.+):(\d+)$/)
		{
		    $dnis = $1;
		    $load = $2;
		    if (! defined ($::Reg))
		    {
			$::Reg = {};
		    };
		    $::Reg->{$dnis} = $load;
		}
		else
		{
		    if ($::Loglevel >= LOG_EROR)
		    {
			logit (LOG_EROR, "invalid reg value \"" .
			       $value . "\" in configuration file, ignoring");
		    };
		};
	    };
	}
	elsif ($param eq "ssml_passthrough")
	{
	    if ($::VgConfig->{$param})
	    {
		$::SSML_Passthrough = 1;
	    };
	}
	elsif (! defined ($config_params->{$param}))
	{
	    if ($::Loglevel >= LOG_EROR)
	    {
		logit (LOG_EROR, "unrecognized parameter \"" .
		       $param . "\" in configuration file, ignoring");
	    };
	};
    };
};

sub usage
{
    my ($message) = shift (@_);

    $SIG{__DIE__} = "DEFAULT";

    if ($message) {die ("voiceglue: " .  $message . "\n");};

    die ("usage: voiceglue [--conffile conffile] [--url url] [--fg]
\t\t[--astsoundprefix soundprefix] [--astsounddir sounddir] [--cmd host[:port]]
\t\t[--cthost cthost] [--ctport ctport] [--user user] [--group group]
\t\t[--loghost loghost] [--loglevel loglevel] [--logdir logdir]

\t\tconffile defaults to /etc/voiceglue.conf and must be present
\t\turl is a single VXML URL to use for all calls
\t\t--fg means to run in the foreground (o.w. starts daemin)
\t\tsoundprefix is directory under /var/lib/asterisk/sounds
\t\t\tthat asterisk sees sound files created
\t\t\tby this program (default 'voiceglue')
\t\tsounddir is a local directory that asterisk sees at
\t\t\t/var/lib/asterisk/sounds/<soundprefix>
\t\t\t(default '/var/lib/asterisk/sounds/<prefix>'
\t\tcthost is the SATC server to use (default 'localhost')
\t\tctport is the SATC server port to use (default 44647)
\t\tloghost is the dynlog server to connect to (no default)
\t\tloglevel is initial loglevel 0-7 (default 7)
\t\tlogdir is the log directory path
\t\t\t(default '/var/tmp/voiceglue')
\t\t\tlogdir of - means log to STDOUT\n");
};

##  parse_command_line_args()
##    -- Does so, and aborts to usage() on errors
sub parse_command_line_args
{
    my ($arg, $type, $cache_dir, $cmd_spec, @pwent, @astpwent);

    ##  Get command line args
    while (defined ($arg = shift (@::ARGV)))
    {
	if ($arg =~ /^--url$/)
	{
	    defined ($::URL = shift (@::ARGV)) || usage();
	}
	elsif ($arg =~ /^--co/)
	{
	    defined ($::Conffile = shift (@::ARGV)) || usage();
	}
	elsif ($arg =~ /^--astsoundp/)
	{
	    defined ($::AstSoundPrefix = shift (@::ARGV)) || usage();
	}
	elsif ($arg =~ /^--astsoundd/)
	{
	    defined ($::AstSoundDir = shift (@::ARGV)) || usage();
	}
	elsif ($arg =~ /^--cmd/)
	{
	    defined ($cmd_spec = shift (@::ARGV)) || usage();
	    if ($cmd_spec =~ /^([^:]+):(\d+)$/)
	    {
		$::Cmd_host = $1;
		$::Cmd_port = $2;
	    }
	    else
	    {
		$::Cmd_host = $cmd_spec;
	    };
	}
	elsif ($arg =~ /^--cth/)
	{
	    defined ($::CT_host = shift (@::ARGV)) || usage();
	    ($::CT_host =~ /^\d+$/) || usage();
	}
	elsif ($arg =~ /^--ctp/)
	{
	    defined ($::CT_port = shift (@::ARGV)) || usage();
	    ($::CT_port =~ /^\d+$/) || usage();
	}
	elsif ($arg =~ /^--logh/)
	{
	    defined ($::Loghost = shift (@::ARGV)) || usage();
	}
	elsif ($arg =~ /^--logl/)
	{
	    defined ($::Loglevel = shift (@::ARGV)) || usage();
	    ($::Loglevel =~ /^\d+$/) || usage();
	    ($::Loglevel >= 0) && ($::Loglevel <= 7) || usage();
	}
	elsif ($arg =~ /^--logd/)
	{
	    defined ($::Log_dir = shift (@::ARGV)) || usage();
	}
	elsif ($arg eq "--fg")
	{
	    $::Foreground = 1;
	}
	elsif ($arg =~ /^--user/)
	{
	    defined ($::User = shift (@::ARGV)) || usage();
	    if ($::User =~ /^\d+$/)
	    {
		$::User_id = $::User;
	    }
	    else
	    {
		scalar (@pwent = getpwnam ($::User))
		  || usage ("user \"$::User\" unknown");
		$::User_id = $pwent[2];
	    };
	    defined ($::Group_id) || ($::Group_id = ($) + 0));
	}
	elsif ($arg =~ /^--group/)
	{
	    defined ($::Group = shift (@::ARGV)) || usage();
	    if ($::Group =~ /^\d+$/)
	    {
		$::Group_id = $::Group;
	    }
	    else
	    {
		scalar (@pwent = getgrnam ($::Group))
		  || usage ("group \"$::Group\" unknown");
		$::Group_id = $pwent[2];
	    };
	    defined ($::User_id) || ($::User_id = $>);
	}
	else
	{
	    usage();
	};
    };

    ##  Check that everything necessary was filled in, and apply defaults
    defined ($::Conffile) || ($::Conffile = "/etc/asterisk.conf");
    defined ($::AstSoundPrefix) || ($::AstSoundPrefix = "voiceglue");
    defined ($::CT_host) || ($::CT_host = "localhost");
    defined ($::CT_port) || ($::CT_port = 44647);
    defined ($::Loglevel) || ($::Loglevel = LOG_EROR);
    $::Logfile = join ("/", $::Log_dir, "voiceglue");

    scalar (@astpwent = getpwnam ("asterisk"))
      || usage ("Cannot find \"asterisk\" account");
    $::Ast_uid = $astpwent[2];

};

sub main
{
    my ($ok, $msg, $current_time, $timeout, $value, $max_fds, $pid);
    my (@events, $fh_spec, $fh, $datumlist, $datum, $input, @pwent);
    my ($pid_dir, $pid_file, $path, $rec, $new_fh);
    my Cam::Scom::Event $event;

    ##  Don't let SIGPIPE kill me
    $::SIG{"PIPE"} = "IGNORE";

    $SIG{__DIE__} = sub { fail ($_[0]) };

    ##  Compute inverse static maps
    foreach $msg (keys (%$::OVXIMsgToOVXIType))
    {
	$value = $::OVXIMsgToOVXIType->{$msg};
	$::OVXITypeToOVXIMsg->{$value} = $msg;
    };

    (($ok, $msg, $max_fds) = &increase_descriptors())[0]
      || fail ("Cannot increase descriptors with setrlimit(): $msg");
    (($ok, $msg) = &enable_core_dumps())[0]
      || fail ("Cannot enable core dumps with setrlimit(): $msg");

    ##  Fix umask
    umask 0000;

    ##  Would like to start log first, but need command line args
    ##  and config file to configure it
    parse_command_line_args();
    read_configfile();

    ##  Verify existence and ownership of log directory
    if ($::Log_dir eq "-")
    {
	$::Logfile = "-";
	$::Log_dir = "/var/tmp/voiceglue";
    }
    else
    {
	$::Logfile = join ("/", $::Log_dir, "voiceglue");
    };
    (-e $::Log_dir)
      && (! (-d $::Log_dir))
	&& system ("rm", "-r", "-f", $::Log_dir);
    (-d $::Log_dir)
      || mkdir ($::Log_dir)
	|| usage ("Cannot mkdir log directory $::Log_dir: $!");
    scalar (@pwent = stat ($::Log_dir))
      || usage ("Cannot stat log directory $::Log_dir: $!");
    if ((defined ($::User_id) && ($pwent[4] != $::User_id)) ||
	(defined ($::Group_id) && ($pwent[5] != $::Group_id)))
    {
	chown ($::User_id, $::Group_id, $::Log_dir)
	  || usage ("Cannot chown log directory $::Log_dir: $!");
    };
    foreach $path (glob("$::Log_dir/*"))
    {
	chown ($::User_id, $::Group_id, $path)
	  || usage ("Cannot chown log file $path: $!");
    };

    ##  Fork daemon
    if (! defined ($::Foreground))
    {
	##  Verify existence of PID directory
	$pid_dir = "/var/run/voiceglue";
	$pid_file = join ("/", $pid_dir, "voiceglue.pid");
	(-e $pid_dir)
	  && (! (-d $pid_dir))
	    && system ("rm", "-r", "-f", $pid_dir);
	(-d $pid_dir)
	  || mkdir ($pid_dir)
	    || die ("Cannot mkdir pid directory $pid_dir: $!\n");
	open (::FH, ">$pid_file")
	  && (print ::FH ("\n"))
	    && close (::FH)
	      || die ("Cannot write pid file $pid_file: $!\n");

	POSIX::setsid();
	chdir ($::Log_dir)
	  || usage ("Cannot cd to log directory $::Log_dir: $!");
	close (STDIN);
	open (STDOUT, ">voiceglue_process.log")
	  || usage ("Cannot open STDOUT to voiceglue_process.log" .
		    " for write: $!");
	open (STDERR, ">&STDOUT")
	  || usage ("Cannot open STDERR dup to STDOUT: $!");
	defined ($pid = fork())
	  || usage ("Cannot fork: $!");
	if ($pid)
	{
	    ##  Write the pidfile
	    open (::FH, ">$pid_file")
	      && (print ::FH ("$pid\n"))
		&& close (::FH)
		  || die ("Cannot write pid file $pid_file: $!\n");
	    exit;
	};
    };

    ##  Step down from root
    if (defined ($::Group_id))
    {
	($), $() = ($::Group_id, $::Group_id);
    };
    if (defined ($::User_id))
    {
	($>, $<) = ($::User_id, $::User_id);
    };

    ##  Have to fork off sound cache process before connecting to log
    ##  This creates the $::Scom instance
    start_sound_cache();

    ##  Have to do this after getting potential --loghost parameter
    ##  from parse_command_line_args() and starting sound cache
    initialize_log();
    if ($::Loglevel >= LOG_NOTI)
    {
	logit (LOG_NOTI,
	       "voiceglue started with $max_fds available descriptors");
    };

    initialize_ovxi ($max_fds);

    initialize_cmd_listener ();

    initialize_ctserver ();

    $::Next_cache_purge_time = time + $::Next_cache_purge_time;

    while (! $::Finished)
    {
	##  Start out assuming no timeout necessary
	$current_time = time;
	$timeout = -1;

	##  If log server is disconnected, set a timeout
	if (defined ($::Loghost) &&
	    $::Time_of_next_connect_to_log_server && ($timeout == -1))
	{
	    $timeout = $::Time_of_next_connect_to_log_server - $current_time;
	    ($timeout < 0) && ($timeout = 0);
	};

	##  Want to wake up once every minute to see if
	##  the day has rolled over or if
	##  cache expiry needs to run
	($timeout == -1) && ($timeout = 60);

	@events = $::Scom->getevents ($timeout);
	$::Now = time;
	while (defined ($datumlist = shift (@events)))
	{
	    $fh = shift (@$datumlist);
	    while (defined ($datum = shift (@$datumlist)))
	    {
		if ($fh eq $::CTSrvFh)
		{
		    ##  Got an event from the CT server
		    if (ref ($datum))
		    {
			##  CT server disconnected
			$event = $datum;
			fail ("CT server disconnected code " .
				    $event->{term});
		    }
		    else
		    {
			##  Message from CT client
			handle_msg_from_ct_server ($::CTSrvInfo, $datum);
		    };
		}
		elsif ($fh eq $::Log_fh)
		{
		    ##  Got an event on the dynlog handle
		    if (ref ($datum))
		    {
			##  Dynlog disconnected
			logtofile (LOG_INFO,
				   "dynlog server disconnected, code " .
				   $event->{term},
				   $::Dynlog_Mymodule, $::Dynlog_Mythread);
			$::Scom->unregister ($::Log_fh);
			$::Time_of_next_connect_to_log_server =
			  time +
			    $::Interval_between_log_server_connect_attempts;
		    }
		    else
		    {
			##  Dynlog message - only one I recognize is
			##  change in loglevel
			foreach $input (split (//, $datum))
			{
			    $input = ord ($input);
			    if (($input >= LOG_EMRG) && ($input <= LOG_DBUG))
			    {
				$::Loglevel = $input;
				if ($::Loglevel >= LOG_DBUG)
				{
				    Vxglue::_set_voiceglue_trace (1);
				}
				else
				{
				    Vxglue::_set_voiceglue_trace (0);
				};
			    };
			};
		    };
		}
		elsif ($fh eq $::VXILog_fh)
		{
		    ##  Got an event on the VXI log handle
		    if (ref ($datum))
		    {
			##  VXIlog disconnected
			logit (LOG_EROR,
			       "VXIlog service disconnected, code " .
			       $event->{term});
			$::Scom->unregister ($::VXILog_fh);
		    }
		    else
		    {
			##  Forward VXIlog messages to generic logger
			handle_vxilog_message ($datum);
		    };
		}
		elsif ($fh eq $::SC_fh)
		{
		    ##  Got an event on the sound cache handle
		    if (ref ($datum))
		    {
			##  Sound Cache disconnected
			logit (LOG_EROR,
			       "Sound Cache disconnected, code " .
			       $event->{term});
			$::Scom->unregister ($::SC_fh);
			$event = $datum;
			fh_stopped ($fh, "code = " . $event->{term});
		    }
		    else
		    {
			handle_soundcache_message ($datum);
		    };
		}
		elsif ($fh eq $::CmdFh)
		{
		    ##  Got an event on the Command Listener handle
		    $event = $datum;
		    if ($event->{end})
		    {
			fh_stopped ($fh, "code = " . $event->{term});
		    }
		    else
		    {
			##  Got a new command connection, register it
			$new_fh = $event->{port};
			if ($::Loglevel >= LOG_INFO)
			{
			    logit (LOG_INFO, "New CMD connection on fh = " .
				   $new_fh);
			};
			$::Clients->{$new_fh} =
			{
			 "type" => FHINFO_TYPE_CMD,
			 "fh" => $new_fh,
			 "host" => four_byte_to_dot_separated
			 ($event->{addr}),
			};
			(($ok, $msg) = $::Scom->register ("$new_fh+"))[0]
			  || logit (LOG_EROR, $msg);
		    };
		}
		elsif (defined ($fh_spec = $::Clients->{$fh}) &&
		       ($fh_spec->{"type"} == FHINFO_TYPE_VXML_INTERP))
		{
		    ##  Got an event from a VXML interpreter

		    if (ref ($datum))
		    {
			##  Handle VXML interpreter fh stoppages
			$event = $datum;
			fh_stopped ($fh, "code = " . $event->{term});
		    }
		    elsif ($fh_spec->{"type"} == FHINFO_TYPE_VXML_INTERP)
		    {
			##  Got a message from a VXML interpreter
			handle_msg_from_vxml_interp ($fh_spec, $datum)
		    }
		    else
		    {
			##  WTF?  We just got a message on a filehandle
			##  that wasn't of an excpected client type
			if ($::Loglevel >= LOG_EROR)
			{
			    logit (LOG_EROR, "rcv from UNEXPECTED " .
				   $::Fhinfo_type_description
				   [$fh_spec->{"type"}] . "\"" . $fh .
				   "\": \"" . $datum . "\"");
			};
		    };
		}
		elsif (defined ($fh_spec) &&
		       ($fh_spec->{"type"} == FHINFO_TYPE_CMD))
		{
		    ##  Got an event on a Command handle
		    if (ref ($datum))
		    {
			##  Command socket disconnected
			logit (LOG_NOTI,
			       "Command handle disconnected, code " .
			       $event->{term});
			$::Scom->unregister ($fh);
		    }
		    else
		    {
			##  Handle command messages
			handle_command_message ($fh, $datum);
		    };
		}
		else
		{
		    ##  WTF?  We just got a message on an unknown filehandle
		    if ($::Loglevel >= LOG_EROR)
		    {
			logit (LOG_EROR,
			       "rcv from UNKNOWN FILEHANDLE \"$fh\": \"" .
			       $datum . "\"");
		    };
		};
	    };
	};

	##  Check for cache purge
	if ($::Now >= $::Next_cache_purge_time)
	{
	    $::Next_cache_purge_time = $::Now + $::Cache_purge_interval;
	    foreach $path (keys (%$::Path_to_status))
	    {
		$rec = $::Path_to_status->{$path};
		if ($rec->{"last_used"}
		    + $::Cache_purge_unused_time < $::Now)
		{
		    unlink (join ("/", $::VgSoundDir, $rec->{"ast_path"}));
		    unlink (join ("/", $::VgSoundDir, $path));
		    delete $::Path_to_status->{$path};
		};
	    };
	};

	##  Check for day rollover
	if ((! defined ($::Last_day)) ||
	    ($::Last_day != (localtime)[7]))
	{
	    log_new_day();
	};

	$current_time = time;
	if ($::Time_of_next_connect_to_log_server &&
	    ($::Time_of_next_connect_to_log_server <= $current_time))
	{
	    ##  Time for another log server connection attempt
	    &opendynlog();
	};
    };

    shutdown_ctserver ();

    shutdown_cmd_listener ();

    shutdown_ovxi();

    stop_sound_cache();

    shutdown_log();

    undef $::Scom;
};

main();

# @::Res = parse_speak_xml ("<?xml version='1.0'?><speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xml:base='http://candide1.plumgroup.com/candide/cs/index.vxml' xml:lang='en'><audio src=\"wav/connecting.wav\" fetchtimeout=\"7s\" fetchhint=\"prefetch\">Connecting</audio></speak>");
# @::Res = parse_speak_xml ("<?xml version='1.0'?><speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xml:base='http://www.talkingstreet.com/ivr/cs/index.vxml' xml:lang='en'><audio src=\"wav/main1.wav\" fetchtimeout=\"7s\" fetchhint=\"prefetch\">To hear one of our celebrity narrated tours, Press 1</audio><audio src=\"wav/main2.wav\" fetchtimeout=\"7s\" fetchhint=\"prefetch\">To listen to sample stops from our Talking Street Tours, press 2</audio><audio src=\"wav/main3.wav\" fetchtimeout=\"7s\" fetchhint=\"prefetch\">To speak to a customer service representative, press 3</audio></speak>");
# @::Res = parse_speak_xml ("<?xml version=\'1.0\'?><speak version=\'1.0\' xmlns=\'http://www.w3.org/2001/10/synthesis\' xml:base=\'http://www.talkingstreet.com/ivr/ver_no_dir/vxml/welcome.php' xml:lang=\'en\'><audio src=\"wav/Soundmark.wav\" fetchtimeout=\"7s\" fetchhint=\"prefetch\" maxage=\"0\"/><audio src=\"WDC/WDC_Welcome.wav\" fetchtimeout=\"7s\" fetchhint=\"prefetch\" maxage=\"0\">\n\x90\x90\x90\x90\x90Welcome to \"Boston: City of Rebels and Dreamers,\" a Talking Street cell-phone walking tour narrated by Steven Tyler.\n\x90\x90\x90\x90</audio></speak>");
##  Pretty-printed:
# <?xml version='1.0'?>
# <speak version='1.0'
#        xmlns='http://www.w3.org/2001/10/synthesis'
#        xml:base='http://www.talkingstreet.com/ivr/ver_no_dir/vxml/welcome.php'
#        xml:lang='en'>
#     <audio src="wav/Soundmark.wav"
#            fetchtimeout="7s"
#            fetchhint="prefetch"
#            maxage="0"/>
#     <audio src="WDC/WDC_Welcome.wav"
#            fetchtimeout="7s"
#            fetchhint="prefetch"
#            maxage="0">
#     \n\x90\x90\x90\x90\x90Welcome to "Boston: City of Rebels and Dreamers," a Talking Street cell-phone walking tour narrated by Steven Tyler.\n\x90\x90\x90\x90
#     </audio>
# </speak>

# use Cam::Form qw(format);
# print ::STDOUT ("Result: ", &format (@::Res), "\n");

sub fakemain
{
    my ($ok, $msg, $platform_handle, $call_handle);

    (($ok, $msg, $platform_handle) =
     Vxglue::_start_voiceglue_platform (1024))[0]
      || die ("Failure from start_voiceglue_platform: $msg");
    (($ok, $msg, $call_handle) =
     Vxglue::_start_voiceglue_thread
     ($platform_handle, 1001,
      "http://localhost/vxml/welcome.vxml",
      "9789735994",
      "9785551212", ""))[0]
	|| die ("Failure from start_voiceglue_thread: $msg");
    sleep (5);
    (($ok, $msg) =
     Vxglue::_stop_voiceglue_thread ($call_handle))[0]
       || die ("Failure from stop_voiceglue_thread: $msg");
    (($ok, $msg) =
     Vxglue::_stop_voiceglue_platform ($platform_handle))[0]
       || die ("Failure from stop_voiceglue_platform: $msg");
};

# print STDOUT ("Run!\n");
# callVXImain (["RunVXID", "-url", "http://localhost/vxml/welcome.vxml"]);
# fakemain();

# VXIrecLoadGrammarFromString called with type "text/x-grammar-choice-dtmf", grammar "<rule id="digit" scope="public"><one-of><item> 0 </item><item> 1 </item><item> 2 </item><item> 3 </item><item> 4 </item><item> 5 </item><item> 6 </item><item> 7 </item><item> 8 </item><item> 9 </item></one-of></rule>"

sub test_tts_hash
{
    my ($tts0) = "Please enter a number.";
    my ($tts1) = "You entered 5!";
    my ($ok, $msg, $res0, $res1);
    ($ok, $msg, $res0) = sc_request_to_params ("tts", $tts0);
    ($ok, $msg, $res1) = sc_request_to_params ("tts", $tts1);
    print ::STDOUT ("\"$tts0\" -> \"$res0\"\n");
    print ::STDOUT ("\"$tts1\" -> \"$res1\"\n");
};

__END__
